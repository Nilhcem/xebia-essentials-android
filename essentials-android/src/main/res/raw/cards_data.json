{
  "categories": [
    {
      "id": 1,
      "color": "#F80068",
      "name": "Craftsmanship"
    },
    {
      "id": 2,
      "color": "#FC7A25",
      "name": "Collaboration"
    },
    {
      "id": 3,
      "color": "#107FD5",
      "name": "Realisation"
    },
    {
      "id": 4,
      "color": "#6DC726",
      "name": "Testing"
    }
  ],
  "cards": [
    {
      "title": "APIs, like diamonds, are forever",
      "url": "apis-are-forever",
      "summary": "<blockquote><b>So craft them carefully:</b><br /><br />APIs should be self-documenting<br />Obey the principle of least astonishment<br />Use consistent parameter ordering across methods<br />APIs should be easy to use, and hard to misuse<br /></blockquote><em>Joshua Bloch</em>",
      "description": "<h3>Motivation</h3> <p>You want to be careful crafting your API. If you don't, then you might end up with something that will hurt you forever. It's not hard to come up with examples of bad API design. Java's XML processing libraries are notoriously awkward to use. Things that should be simple require tons of boilerplate code.</p> <p>Joshua Bloch presented his ideas on API design in a talk named 'How to Design a Good API and Why it Matters' at OOPSLA 2006. It comprises a set of criteria that are fairly easy to remember, as they are all small enough to fit on a bumper sticker:</p> • All programmers are API designers<br> • APIs can be among your greatest assets or liabilities<br> • Public APIs, like diamonds, are forever<br> • APIs should be easy to use and hard to misuse<br> • APIs should be self-documenting<br> • When designing an API, first gather requirements - with a healthy degree of skepticism<br> • Structure requirements as use-cases<br> • Early drafts of APIs should be short<br> • Code the use-cases against your API before you implement it<br> • Maintain the code for use-cases as the API evolves<br> • Example code should be exemplary<br> • You can't please everyone so aim to displease everyone equally<br> • Expect API-design mistakes due to failures of your imagination<br> • API design is not a solitary activity<br> • Avoid fixed limits on input sizes<br> • Names matter<br> • If it's hard to find good names, go back to the drawing board<br> • When in doubt leave it out<br> • Keep APIs free of implementation details<br> • Minimize mutability<br> • Documentation matters<br> • Consider the performance of consequences of an API design decisions, but don't warp an API to achieve performance gains<br> • When in Rome, do as the Romans do<br> • Minimize accessibility<br> • Subclass only if you can say with a straight face that every instance of the subclass is an instance of the superclass<br> • Design and document for inheritance or else prohibit it<br> • Don't make the client do anything the library could do<br> • Obey the principle of the last astonishment<br> • Fail fast<br> • Provide programmatic access to all data available in string form<br> • Overload with care<br> • Use the right data type for the job<br> • Use consistent parameter ordering across methods<br> • Avoid long parameter names<br> • Avoid return values that demand exceptional processing<br> • Throw exceptions only to indicate exceptional conditions<br> • Throw unchecked exceptions unless clients can realistically recover from the failure<br> • API design is an art, not a science<br> <br> <h3>Applicability</h3> <p>Always.</p> <h3>Application</h3> • Use it while designing the API<br> • Use it while coding<br> • Use it while reviewing code<br> • Use it while pair programming<br> <br> <p>It might be good idea to read the list before you go off to design something significant, or always have a printed version of the list close to where you are.</p> <h3>Consequences</h3> <p>The only negative consequence I can imagine related to trying to follow the guidelines given by Josh are - perhaps - analysis paralysis. Pair programming will prevent that. In fact, just by pair programming and have your buddy remind you of API design bumper stickers, you might have all the benefits without the chance of analysis paralysis.</p> <p>Now, some people might argue that following these standards doesn't address a particular business value for the customer, but then I disagree. It is your responsibility as a programmer to create good code. Don't be tempted to create something messy just because you are in a hurry. Chances are that - if you work like that - it will bite back and result in major head aches when you need to overhaul your code later on.</p> <p>In order to avoid any discussions on taking the time to work according the guidelines given above, consider making it part of your definition of done, and make sure everybody agrees on that.</p> <h3>Samples</h3> <p>Less than great API design samples, often serving in examples in Joshua Bloch's talk: JAXP</p> <h3>References</h3> • <a href=\"http://www.infoq.com/articles/API-Design-Joshua-Bloch\">InfoQ Article</a><br> • <a href=\"http://www.infoq.com/presentations/effective-api-design\">Video recorded at JavaPolis</a><br> • <a href=\"http://essentials.xebia.com/code-review\">code-review</a><br> • <a href=\"http://essentials.xebia.com/comment-with-care\">comment-with-care</a><br> <br>",
      "category": 3,
      "bitly": "hJOvvL"
    },
    {
      "title": "Aim for thread safety",
      "url": "thread-safe",
      "summary": "In order of decreasing safety:<br /><br /> • Stateless services<br /> • Immutable shared state<br /> • Encapsulated locks<br /> • Not thread safe",
      "description": "<h3>Motivation</h3> <p>When your code should be thread safe but isn't, you will find out too late at an inconvenient time. This can lead to embarrassing situations where you need to fix a hard problem under high pressure. Not good. If you apply these simple rules you will avoid this.</p> <h3>Applicability</h3> <p>Whenever you use objects in multiple threads they must be thread safe. This can go for services that are shared, but also for value objects that are passed along.</p> <h3>Application</h3> <p>The only risk of thread unsafe code is that state is not appropriately shared, so all the rules apply to state.</p> <p>The first rule applies to services. If an object simply doesn't hold any state it is always thread safe. Virtually all applications must hold state to be useful. In particular services need to collaborate with other services. The rules are bent usually, when people say \"stateless service\" they usually mean \"services that don't hold any state, but the immutable references to other services\".</p> <p>Immutable objects are usually the objects passed around in an application. If the state in an object cannot be changed after creation, there is no risk of one client seeing a different state than another. Creating an object as being immutable should be the default choice. Anything that mutates state is potentially dangerous.</p> <p>Encapsulated locks is the last resort. If an object has to be changed during its lifetime, this is the only way to ensure thread safety. Locking on the object itself is also thread safe, but it can cause unwanted locking and even deadlocks if others are locking on it too.</p> <p>Non thread safe code is not a problem in many situations. As long as objects are not shared with multiple threads, making them thread safe is adding complexity that is not needed. Many web applications are built around non thread safe domains, and this is not a problem. Be sure to make it clear that code is not thread safe and will not be used out of the safe context it is supposed to be used in.</p> <h3>References</h3> <p>Brian Goetz: Java Concurrency in Practice</p>",
      "category": 3,
      "bitly": "gbXjXc"
    },
    {
      "title": "Alone time",
      "url": "alone-time",
      "summary": "For some situations pair programming is not effective.<br />Be prepared to allow yourself and your team members to have some <b>time alone</b>.",
      "description": "<p>For some situations pair programming is not effective. Be prepared to allow yourself and your team members to have some time alone.</p> <h3>Motivation</h3> <p>Even though we love pair programming, we can't expect anyone to constantly think out loud. When some seriously deep thinking needs to happen, or you just need to fiddle with something to find the right questions to ask; pair programming can block you. For these situations and just to keep the joy of solving a puzzle in isolation in the work alone time is great.</p> <h3>Applicability</h3> <p>Any work on a problem that is not resulting in production code might be a candidate for some alone time. In particular when you get into a situation as a pair that you're both looking at the other for ideas it might be time to split up, scour the internet fret with some ideas and reconvene when you've found some clues. Doing nothing is also a very important part of creative work. Alone time might be needed even if there is no work that deserves being done by someone on their own.</p> <h3>Application</h3> <p>Timebox alone time. Make a date with a pair buddy before you go off on what might very well be a wild goose chase. Then when the timebox is over assess the situation with someone else. The harder the problem is, the harder it will be initially to get somewhere. Sometimes great ideas come to you while you're ironing your shirt or making a sandwich. Sometimes staring out of a window for a couple of hours is the most productive thing you can do. Setting up rules for how people should spend alone time defeats the purpose.</p> <h3>Consequences</h3> <p>Enforced pairing should not be for 100% of the time. Alone time gives the brain time to recharge and ideas time to react with each other. All production code should be written in pairs. It follows that we must not plan people to work in pairs on production code 40 hours a week. 100% efficiency is unhealthy in creative teams.</p> <h3>References</h3> <p> <a href=\"http://essentials.xebia.com/pair-programming\">pair-programming</a></p> <p> <a href=\"http://essentials.xebia.com/the-zone\">the-zone</a></p> <p> <a href=\"http://essentials.xebia.com/no-multitasking\">no-multitasking</a></p>",
      "category": 2,
      "bitly": "ghjkXd"
    },
    {
      "title": "Assert against improper behaviour",
      "url": "assertions",
      "summary": "<blockquote>If it can't happen, use assertions to assure it won't.</blockquote><em>Andy Hunt and Dave Thomas</em>",
      "description": "<h3>Motivation</h3> <p>Ideally, the compiler would be able to verify all of your assumptions. In reality, it can't. Next question is if you would be able to write tests for all of those situations. After all, that's what you normally do for all circumstances in which the compiler is not helping. In reality, that doesn't work out either. The combinatorial explosion of states your modules might go into is just overwhelming.</p> <p>This is where assertions come to the rescue. Assertions allow you to validate pre- and postconditions and can help you to assure your invariants hold. Putting in assertions will make sure your code fails early before causing anymore damage. It also works as a mental flag.</p> • You think you're sure something will never happen =&gt;<br> • The rule tells you to put an assertion in =&gt;<br> • You start to consider if your assumption actually holds in all circumstances =&gt;<br> • You might alter your code based on the conclusion =&gt;<br> • You put in an assertion<br> <br> <h3>Applicability</h3> <p>Always. Don't go overboard and assert everything though. As I said, one of the most important reasons for having assertions is to train your consciousness to find the conditions in which your assumptions no longer hold.</p> <h3>Application</h3> <p>There are a couple of flavors for doing assertions in Java out there.</p> <p>Java keyword:</p> <pre><code>assert (x &gt; 3);</code></pre> <p>Disadvantage: they get disabled by default.</p> <p>Spring Assert class:</p> <pre><code>Assert.isTrue(x &gt; 3);</code></pre> <p>Disadvantage: no isolated jar; you pull in a significant number of classes.</p> <p>Guava <a href=\"http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/base/Preconditions.html\">Preconditions</a> class:</p> <pre><code>Preconditions.checkArgument(x &gt; 3)</code></pre> <h3>Consequences</h3> <p>If you put in assertions, then your code will fail if the assertions are violated. Don't try to catch these exceptions. If you are catching AssertionErrors, then you probably misused assertions for some other purpose.</p> <h3>References</h3> • <em>Programming Defensively</em> Interview with Andy Hunt and Dave Thomas, <a href=\"http://www.artima.com/intv/defense.html\">http://www.artima.com/intv/defense.html</a><br> <br>",
      "category": 3,
      "bitly": "ejk4l4"
    },
    {
      "title": "Automate the entire release and deployment process",
      "url": "automate-everything",
      "summary": "The release and deployment process should be fast, reliable and repeatable several times a day.",
      "description": "<h3>Motivation</h3> <p>Software release and deployment processes are often riddled with manual steps and hand offs. This makes the release process slow, error prone and expensive.</p> <h3>Applicability</h3> <p>Whenever there are manual processing steps or hand-offs involved in your release and deployment process, you should automate it.</p> <h3>Application</h3> • automate the build process with CI servers like Jenkins or Bamboo<br> • automate the deployment process with Application Release Automation products like Deployit<br> • automate the acceptance testing with products like Jbehave and Cucumber<br> • automate the system integration tests with Fitnesse and Selenium<br> • automate the installation and configuration of machines and middleware with products like Puppet and Chef.<br> <br> <h3>Consequences</h3> <p>Once your software delivery process is automated, you will be able to deploy new versions of your application faster, more frequently with less errors and man power.</p>",
      "category": 3
    },
    {
      "title": "Be curious",
      "url": "curiosity",
      "summary": "<blockquote>Curiouser and curiouser!</blockquote><em>Alice in Wonderland</em><br /><br />Curiosity is one of the main sources of creativity.",
      "description": "<h3>Motivation</h3> <p>Four reasons why curiosity is important:</p> <h4>It makes your mind active instead of passive</h4> <p>Curious people always ask questions and search for answers in their minds. Their minds are always active. Since the mind is like a muscle which becomes stronger through continual exercise, the mental exercise caused by curiosity makes your mind stronger and stronger.</p> <h4>It makes your mind observant of new ideas</h4> <p>When you are curious about something, your mind expects and anticipates new ideas related to it. When the ideas come they will soon be recognized. Without curiosity, the ideas may pass right in front of you and yet you miss them because your mind is not prepared to recognize them. Just think, how many great ideas may have lost due to lack of curiosity?</p> <h4>It opens up new worlds and possibilities</h4> <p>By being curious you will be able to see new worlds and possibilities which are normally not visible. They are hidden behind the surface of normal life, and it takes a curious mind to look beneath the surface and discover these new worlds and possibilities.</p> <h4>It brings excitement into your life</h4> <p>The life of curious people is far from boring. It's neither dull nor routine. There are always new things that attract their attention, there are always new 'toys' to play with. Instead of being bored, curious people have an adventurous life.</p> <h3>Applicability</h3> <p>Applies to every aspect of your work.</p> <h3>Application</h3> <p><em>1. Keep an open mind</em></p> <p>This is essential if you are to have a curious mind. Be open to learn, unlearn, and relearn. Some things you know and believe might be wrong, and you should be prepared to accept this possibility and change your mind.</p> <p><em>2. Don't take things as granted</em></p> <p>If you just accept the world as it is without trying to dig deeper, you will certainly lose the 'holy curiosity'. Never take things as granted. Try to dig deeper beneath the surface of what is around you.</p> <p><em>3. Ask questions relentlessly</em></p> <p>A sure way to dig deeper beneath the surface is asking questions: What is that? Why is it made that way? When was it made? Who invented it? Where does it come from? How does it work? What, why when who where and how are the best friends of curious people.</p> <p><em>4. Don't label something as boring</em></p> <p>Whenever you label something as boring, you close one more door of possibilities. Curious people are unlikely to call something as boring. Instead, they always see it as a door to an exciting new world. Even if they don't yet have time to explore it, they will leave the door open to be visited another time.</p> <p><em>5. See learning as something fun</em></p> <p>If you see learning as a burden, there's no way you will want to dig deeper into anything. That will just make the burden heavier. But if you think of learning as something fun, you will naturally want to dig deeper. So look at life through the glasses of fun and excitement and enjoy the learning process..</p> <p><em>6. Read diverse kinds of reading</em></p> <p>Don't spend too much time on just one world; take a look at another worlds. It will introduce you to the possibilities and excitement of the other worlds which may spark your interest to explore them further. One easy way to do this is through reading diverse kinds of reading. Try to pick a book or magazine on a new subject and let it feed your mind with the excitement of a new world.</p> <p>Make sure curiosity is not making you lose focus. Also be aware that some things simply are not your business. Don't confuse curiosity with nosiness.</p> <h3>Consequences</h3> <p>Curiosity feeds creativity and inspiration. It makes you a better problem solver. It stops you from becoming a one-trick pony.</p> <h3>References</h3> • 4 Reasons Why Curiosity is Important, Donald Latumahina, <a href=\"http://www.lifehack.org/articles/productivity/4-reasons-why-curiosity-is-important-and-how-to-develop-it.html\">http://www.lifehack.org/articles/productivity/4-reasons-why-curiosity-is-important-and-how-to-develop-it.html</a><br> <br>",
      "category": 1,
      "bitly": "g1oGb1"
    },
    {
      "title": "Beware of anemic domain models",
      "url": "no-anemic-domain-model",
      "summary": "<b>Anemic domain models</b> are data structures without any behaviour.<br />They are a sign of poor object-oriented modelling.<br /><br />Domain-Driven Design (Eric Evans) is an alternative that takes better advantage of the object-oriented model's strengths and improves code maintainability.",
      "description": "<p>In <strong>Object Oriented Programming</strong>, an Anemic Domain Model is a program design consisting of data classes without any behaviour and procedural of \"service\" classes to manipulate them. These systems tend to spawn utility classes full of static methods in an effort to <a href=\"http://essentials.xebia.com/dry-principle\">fight code duplication</a>. As the number of utility functions increases, developers lose track and the utilities themselves start to get duplicated. The result is a system that's not cohesive and <a href=\"http://essentials.xebia.com/maximize-cohesion-minimize-coupling\">tightly coupled</a>. Overall, the high level design appears to be pretty clear, but the source code design tends to get messy. Most simply put, these systems suffer the extra complexity of using an Object Oriented programming language, without reaping any of the benefits.</p> <p>It must be noted that \"structs and procedures\" is itself a perfectly valid software design. It's just not a very good fit for Object Oriented programming languages.</p> <p>One of the core ideas of the Object Oriented model is to bring code and data together. <a href=\"http://en.wikipedia.org/wiki/Domain-driven_design\">Domain-Driven Design</a> (a technique described by Eric Evans in <a href=\"http://www.bol.com/nl/p/domain-driven-design/1001004001984629\">a book</a> of the same name) is a technique that fully embraces this idea. Systems modeled in this way naturally follow the SOLID principles and naturally avoid code duplication. They make the most of the object oriented model.</p> <p>There's a middle ground between the two, where an anemic domain model system is improved by bringing some of the behaviour into the domain model. The easiest place to begin is all those utility functions, starting with simple things like validations and formatting rules. Taking these out of the utility classes and pushing them into the model classes makes them easier to find (avoiding accidental duplication) and improves code cohesion. This approach can be a good fit for request processing systems, such as web apps, where embracing a full object oriented domain model might make things harder to parallelize.</p>",
      "category": 3,
      "bitly": "hfjbRD"
    },
    {
      "title": "Brutal Transparency",
      "url": "brutal-transparency",
      "summary": "The only way to build <b>trust</b> is to be honest and transparent under all circumstances.",
      "description": "<p>The only way to build trust is to be honest and transparent under all circumstances.</p>",
      "category": 2,
      "bitly": "dK5OCf"
    },
    {
      "title": "Comment with care",
      "url": "comment-with-care",
      "summary": " • Don't document bad code - rewrite it<br /> • Don't repeat the code - clarify its intent<br /> • Document surprises and workarounds<br /> • Make every comment count",
      "description": "<h3>Motivation</h3> <p>Getting the comments right is as hard (and important) as getting the source code right. Having too many comments in a file can be as detrimental to maintainability as having too few [citation needed], comments can be useless and the worst are incorrect or misleading.</p> <p>Source code comments can assert intellectual property ownership and licensing terms.</p> <h3>Applicability</h3> <p>Every modern programming language I'm aware of supports source code comments.</p> <h3>Application</h3> • In an object-oriented language such as Java (1), it's fair to demand a type-level JavaDoc header that describes the intent and responsibility of the class or interface on every public or protected type.<br> • On APIs intended for use by others, every public method and field should be appropriately documented.<br> • Use the standard documentation system for the platform. In Python, that's doc strings. In Java, that's JavaDoc. The standard documentation system is not only familiar to humans, most IDEs and some editors know how to read it too. As obvious as this may seem, I more than once had the displeasure of using a closed-source API documented using a proprietary HTML layout not in any way resembling standard JavaDoc. It was painful.<br> <br> <p>Guidelines aside, whenever you find yourself wondering: \"I wonder whether this'll make sense to me later\", you know it's time for a comment. Ensure the comment contains information that cannot be obtained by simply reading the code itself.</p> <p>Beware if inline comments, though! Most of the time when you find yourself adding comments to a particular line of code, it's time to move that code to it's own function or method and provide that with a descriptive name.</p> <h3>Consequences</h3> <p>Effective use of source code comments improves the maintainability of program code. Coming back to your or someone else's code to add a feature or carry out a fix will take a matter of minutes or hours, rather than days or weeks.</p> <h3>Samples</h3> <h1>Don't document bad code - rewrite it.</h1> <p>The <a href=\"http://en.wikipedia.org/wiki/Comment_%28computer_programming%29\">Wikipedia article on commenting</a> ascribes this aphorism to The Elements of Programming Style [3]. It's a good general guideline, but it may not always be feasible, especially in maintenance projects.</p> <h1>Don't repeat the code - clarify its intent.</h1> <p>Code Complete [1] illustrates this with a nice example. Which is more clarifying?</p> <pre><code>// If account flag is zeroif (accountFlag == 0) ...</code></pre> <p>or</p> <pre><code>// If establishing a new accountif (accountFlag == 0) ...</code></pre> <p>Maybe the intent can be clarified just as much without a comment:</p> <pre><code>if (establishNewAccount()) ...private boolean establishNewAccount() {    return accountFlag == 0;}</code></pre> <h1>Document surprises and workarounds.</h1> <p>\"Surprises and workarounds\" is deliberately vague, as it's very hard to qualify. A common scenario is that you add a special case in a method to fix a bug or when you find out that a library behaves differently than you thought it would because it bites you during testing.</p> <p>An example of this is when I found out that a Java 1.5 ThreadPoolExecutor with a corePoolSize of 0, a maxPoolSize of 50 and an unbounded task queue does not idle at 0 threads and execute at 50, but rather, starts 0 threads and executes nothing at all. When I dug into this, I found out that Java 1.5 has no way to make a ThreadPoolExecutor idle at 0 threads (Java 1.6 does) and that in both versions maxPoolSize is meaningless with an unbounded queue. I put a short note above the variable declaration to benefit any maintenance programmer that needs to adjust the pool sizes.</p> <p>A special case of this is where source code analysis tools report a false positive. A great example of this is the <a href=\"http://digitaloffense.net/tools/debian-openssl/\">Debian OpenSSL</a> fiasco of a few years back. The random number generator contained what appears to be bad use of uninitialized memory (and was reported as such by code analysis tools), but which was essential to seeding the random number generator. Someone removed the line in a clean-up effort and the result was two years' worth of SSL certificates each of which could be brute-forced in at most 32768 attempts.</p> <h1>Make every comment count.</h1> <p>Excessive comments are just clutter.</p> <h1>Good: The java.util.concurrent package</h1> <p>The JavaDoc comments in the java.util.concurrent package are outstanding. They're short and to the point where possible, meticulously detailed where required.</p> <h1>Bad: Eclipse getters and setters</h1> <p>Eclipse's default template for the JavaDoc comment on getters and setters is horrible.</p> <pre><code>/** * @param foo the foo to set */public void setFoo(String foo) {    this.foo = foo};/** * @return the foo */public String getFoo() {    return foo};</code></pre> <p>These comments are grammatically ugly. Worse, the comments don't add any value: we know what a getter or setter does and if a method does something else it shouldn't masquerade as a getter or setter in the first place. Don't generate comments using this template, just leave them out.</p> <p>If your architect/analysis tool/standards body won't let you get away with undocumented getters and setters, at least replace the template by something grammatically correct.</p> <h1>Good: Unit, bounds, resolution, precision</h1> <p>When dealing with measurements and amounts, make sure the unit, resolution and bounds are apparent. It's often possible and desirable to make this information programmatically available, such as with java.util.Currency or JSR-275. Failing that, you can resort to code comments such as in the next example.</p> <pre><code>&lt;xsd:element name=\"admission\" type=\"xsd:dateTime\"&gt;    &lt;xsd:annotation&gt;        &lt;xsd:documentation&gt;            The date and time of admission. Precision is in minutes, the            seconds are always 00. UTC offset is not included, all values            are in the Europe/Amsterdam time zone.        &lt;/xsd:documentation&gt;    &lt;/xsd:annotation&gt;&lt;/xsd:element&gt;</code></pre> <p>The xsd:dateTime has a resolution in seconds (optionally milliseconds) and an optional UTC offset. The UTC offset is required to unambiguously pinpoint a calendar date and time on the time continuum. If the actual offset is unavailable, a time zone is the next best thing. The fact that we\"re using an xsd:dateTime instead of an xsd:string has documentary value in and of itself.</p> <h3>References</h3> • Code Complete (Steve McConnell, Microsoft Press), pages 777-817.<br> • The Pragmatic Programmer (Hunt/Thomas, Addison Wesley), page 249-251.<br> • The Elements of Programming Style (Kernighan/Plauger, Mcgraw-Hill)<br> <br> <h3>Footnotes</h3> • Some argue Java isn't an object oriented language. It's close enough for the purposes of this article.<br> <br>",
      "category": 1,
      "bitly": "fdHw86"
    },
    {
      "title": "Dare to say no",
      "url": "dare-to-say-no",
      "summary": "In Software Engineering, some things are just not possible.<br /><b>Stand up for your values</b> as a professional and refuse to do them!<br />A good doctor will not promise to heal everything either.",
      "description": "<h3>Also known as</h3> <p>First, do no harm.</p> <h3>Motivation</h3> <p>In software engineering, not everything is possible.</p> <h3>Applicability</h3> <p>As a software engineer, you are a skilled professional with knowledge, experience and expertise in software development. As such, you can judge when something might be possible (\"if we work flat-out we might just be able to hack it together in time...\") but would simply be bad (\"...but it sure will be one unmaintainable, ugly beast of a piece of code.\"). Don't allow your software to cause you sleepless nights.</p> <h3>Application</h3> <p>Don't let yourself be pressured into committing to delivering features that simply cannot be delivered to the standard of quality you, as a professional, regard as necessary. If the Product or business owner says that there \"must be a way\", that there must be some <a href=\"http://essentials.xebia.com/clean-build\">corners</a> <a href=\"http://essentials.xebia.com/dry-principle\">you</a> <a href=\"http://essentials.xebia.com/code-review\">can</a> <a href=\"http://essentials.xebia.com/boy-scout-rule\">cut</a> or <a href=\"http://essentials.xebia.com/test-everything\">tests you can skip</a>, ask them if they would trust a surgeon who would happily skip the disinfection in order to save 10 minutes.</p> <h3>Consequences</h3> <p>Software engineers pride themselves on solving problems and \"doing the impossible\". This can lead to the expectation that there is always a way. Prepare to push back in such environments, and remember that as a professional yours is an expert opinion that cannot simply be ignored by a business owner without serious consequences for you both.</p> <h3>References</h3> • <a href=\"http://manifesto.softwarecraftsmanship.org/\">Manifesto for Software Craftsmanship</a><br> • <a href=\"http://www.infoq.com/presentations/craftsmanship-ethics\">Craftsmanship and Ethics, Robert C. Martin</a><br> <br>",
      "category": 1,
      "bitly": "g4NpmH"
    },
    {
      "title": "Deal with non-functionals",
      "url": "non-functionals",
      "summary": "Work all your <b>non-functional requirements</b> into <b>goals</b> on a clearly defined scale and put them on the backlog, either as part of the 'Definition of DONE' or as separate user stories.",
      "description": "<h3>Motivation</h3> <p>Product owners are normally more concerned about things you can do with the solution you are building than about the quality of what it can do. As a result, items turning up on the backlog are mostly related to a feature (as in, something the user can do) rather than overall quality. From the product owner's perspective, the team might be making good progress, whereas in reality what is getting produced will never be able to cope with what can be expected to happen when going live.</p> <h3>Applicability</h3> <p>Every project should carefully consider the quality related attributes that need to be addressed. That does not necessarily mean that all projects need to have the same non-functional requirements. In fact, in some cases, after short but conscious consideration, the decision might be to just ignore non-functional requirements altogether. (In case of a one-off script?)</p> <h3>Application</h3> <p>Setting proper objectives for non-functionals is not easy. The problem is: your product owner (ideally the money owner) might have a hard time understanding what these quality attributes are all about. Yet, at the same time, you want to make sure that the product owner backs the plan to address a particular quality requirement, so you do want them to understand what they are essentially asking for.</p> <p>One way to address it is by avoiding scales that are (mostly) well understood by developers, but not by non-IT people. So, you just define your own scales that are meaningful in the minds of the product owners. In some cases, that means defining some higher-order quality requirements, from which you then derive the lower-level quality requirements with related measurable scales that can be translated in actual work to be done.</p> <p>One way or the other, the quality requirements eventually need to be translated into user stories, or be woven into the definition of done of other stories. You need the product owner's awareness of the fact that you are going to work on this, and you do want him to understand the relevance of it all.</p> <p>One of the best sources of working this way is probably Gilb's 'Competitive Engineering'. You might not need to adopt his language. In most cases, it will be fine to define your own, one that is based on terminology that is well understood by the team. Aim for the riskiest non-functional requirements first.</p> <h3>Consequences</h3> <p>Spending time on working out the quality requirements with your product owner is going to take time. Plan for it. Start early, and refine the requirements iteratively.</p> <h3>References</h3> • <a href=\"http://books.google.nl/books?id=ejxQF60xVV0C&amp;dq=competitive+engineering&amp;printsec=frontcover&amp;source=bn&amp;hl=nl&amp;ei=UMSATPmeF4L_Ocq-rNIJ&amp;sa=X&amp;oi=book_result&amp;ct=result&amp;resnum=4&amp;ved=0CDAQ6AEwAw#v=onepage&amp;q&amp;f=false\">Competitive Engineering</a>, Tom Gilb, 2005<br> <br>",
      "category": 3,
      "bitly": "ePpC8W"
    },
    {
      "title": "Develop for security",
      "url": "secure-development",
      "summary": "You can't successfully add <b>security</b> to an existing insecure system. Consider security requirements during all steps of your development process.",
      "description": "<h3>Motivation</h3> <p>The internet hasn't been the safe, naive place it once was for a couple of decades now. Any connected system runs the risk of being targeted for a variety of kinds of attack, or used as an intermediary to attack some other target.</p> <h3>Applicability</h3> <p>Security is often an implied requirement; few words are spent on the topic, but customers expect their systems to be built secure. Practical security is a trade-off: it's not feasible to be 100% secure. Different systems emphasize different aspects of security and attract different kinds of attackers. Therefore, what's adequate for one system is overkill (or completely missing the point) for another.</p> <h3>Application</h3> <p>Security is not something that can be bolted on after release, nor is it something that only concerns development. Securing a system starts during its initial, broad-strokes design and lasts all the way through its maintenance phase until the system is decommissioned. Identify which security properties are important, both to yourself (e.g. availability) and to your users (e.g. protection from identity theft). Embed these in your <a href=\"http://essentials.xebia.com/acceptance-criteria\">Acceptance Criteria</a>. Identify which legal or industry standards apply. Employ secure coding practices. Identify abuse cases and test against them. Think about security aspects while <a href=\"http://essentials.xebia.com/code-review\">reviewing code</a>. Consider incident response. Be aware that it's a perfectly valid decision to accept certain risks, just do so knowingly.</p> <h3>References</h3> <p>There is an enormous amount of literature, tools and online documentation on this subject. The <a href=\"https://www.owasp.org/index.php/Main_Page\">OWASP project</a> has extensive, free resources and is a good place to start looking. The <a href=\"http://www.microsoft.com/security/sdl/default.aspx\">Security Development Lifecycle</a> is a system that Microsoft adopted in the mid-2000's to address these concerns at every stage.</p>",
      "category": 3
    },
    {
      "title": "Diagnose before cure",
      "url": "diagnose-before-cure",
      "summary": "<b>Measure</b> first, make an <b>isolated change</b>, <b>repeat</b> until satisfied.<br /><br />Before you tune preformance, first measure it. Then fix the worst bottleneck and measure again. Commonly you will find that bottlenecks shift, and you are most effective when continuously measuring your progress.",
      "description": "<p>When solving problems in a software system, make sure you're attacking them from the right angle. This is true in general, but particularly so for problems meeting your <a href=\"http://essentials.xebia.com/non-functionals\">non-functional</a> requirements, like throughput and scalability. Bottlenecks in your performance characteristics may not be where you think they are. Your hands may be itching to tune that one really complicated database operation, but if your most pressing problem is synchronization for a System.out.println call that was accidentally left in, than tuning that query may be an utter waste of time.</p> <h3>Applicability</h3> <p>When performance tuning an application.</p> <h3>Application</h3> <p>Before you tune performance, first measure it. Identify the bottleneck, fix that, and measure again. Measure, then fix one problem, verify that it worked, then repeat. Plan, do, check, adapt. Commonly you will find unexpected results and you are most effective when measuring your progress.</p> <h3>Consequences</h3> <p>You actually identify and fix those bottlenecks that are causing contention in your application, rather than tweaking where things \"look bad\".</p>",
      "category": 1,
      "bitly": "fH3Ru4"
    },
    {
      "title": "Don't Repeat Yourself",
      "url": "dry-principle",
      "summary": "<blockquote>Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.</blockquote><em>Andy Hunt and Dave Thomas</em>",
      "description": "<h3>Also known as</h3> • The DIE Principle: Duplication Is Evil<br> • SPOT: Single Point Of Truth<br> <br> <h3>Motivation</h3> <p>Duplication leads to maintenance hell and logic contradictions, reducing seems a Good Thing™.</p> <h3>Applicability</h3> <p>The original authors of the quotes stated that it could be applied to \"database schemas, test plans, the build system, even documentation.\". So practically it could be applied almost in any aspect of work. It applies very well to code duplication.</p> <h3>Application</h3> <p>The DRY principle applied to code can reduces the amount of code you have to deal with. It improved readability and thus makes maintenance easier. When coding you can use a wide variety of options to limit duplication, OO paradigms, refactoring options etc...</p> <p>The DRY principle should also be used beyond plain coding in the design phase: Two concepts which are not bound in the system should not be bound by code. This is a little bit more difficult to apply.</p> <h3>Consequences</h3> <p>Whenever the principle is correctly applied it any change to any element in the system should not imply modification to other element of the system which are not directly related. Likewise, the modification should imply predictable and uniform change to all related elements.</p> <h3>Samples</h3> <p>TBD Stories from the trenches? Horror stories? Source code? Customer references? Samples of technology that can be used to put it into practice?</p> <h3>References</h3> • <a href=\"http://www.artima.com/intv/dryP.html\">Orthogonality and the DRY principle</a><br> • <a href=\"http://codebetter.com/blogs/karlseguin/archive/2009/09/12/unit-testing-do-repeat-yourself.aspx\">DRY Principle not applied to Unit Test</a><br> <br>",
      "category": 1,
      "bitly": "fh7McI"
    },
    {
      "title": "Done = Live!",
      "url": "done-is-live",
      "summary": "The work of the development team is only <b>done</b> when the feature is <b>live</b> in production.",
      "description": "<h3>Motivation</h3> <p>Whenever there is a strong separation between development, QA and operations, developers are often unaware of the problems and issues that are encountered when the software is put in production. In these situation, the developer assumes that the work is done after the checked changes are checked in into the version management system and marked as resolved in the issue tracking system. But until the change is in production, it is unsure whether the work is really finished.</p> <h3>Applicability</h3> <p>This principle is applicable for any organisation where creating software is strictly separated from maintaining, running and operating the software. Note that this is generally a poor way of structuring a development organisation. It's more effective if the original developers of a piece of code <a href=\"http://essentials.xebia.com/build-it-run-it\">are also its stewards</a>.</p> <h3>Application</h3> <p>Create multi-disciplinary teams and make sure that the team's work is defined as done, only when the change has been put into production and is in working to satisfactorily.</p>",
      "category": 2
    },
    {
      "title": "Eliminate waste",
      "url": "eliminate-waste",
      "summary": "Sources of waste in software development include:<br /><br /> • Partially done work<br /> • Extra features<br /> • Relearning<br /> • Task switching<br /> • Hand-offs<br /> • Delays<br /> • Defects",
      "description": "<h3>Motivation</h3> <p>Waste is the result of activities or environmental conditions that prevent a team from reaching its goal. That clearly can't be good, so you need to get rid of it.</p> <h3>Applicability</h3> <p>Waste manifests itself in many different ways. It's way easier to find processes that produce waste, than to find processes that don't produce any waste at all. So just consider this one to be applicable in all circumstances.</p> <h3>Application</h3> <p>In order to eliminate waste:</p> <p>Waste, and its underlying causes, have to be detected and identified.</p> <p>Changes to the work environment need to be made to both eliminate the cause of the waste and the waste itself</p> <p>One of the approaches that may help eliminating waste is <em>value stream mapping</em>:</p> <p>Value stream mapping is one particular tool that can be used by a team or organization to identify wasteful activities. The team describes the amount of time that work takes to go through each activity in their overall work process. Next, the team determines if each activity adds value or does not add value to the end goal. All activities are subject to speed improvements, and activities that do not add value are subject to elimination.</p> <h3>Consequences</h3> <p>There is a lot of value in reducing waste:</p> • Frustration ↘<br> • Productivity ↗<br> • Creativity ↗<br> • Speed ↗<br> • Delivery of value ↗<br> • Reduce defects ↗<br> <br> <h3>References</h3> • <a href=\"http://www.agileadvice.com/archives/2005/04/eliminate_waste.html\">Eliminate Waste</a><br> <br>",
      "category": 2,
      "bitly": "fAE0fA"
    },
    {
      "title": "Fail fast",
      "url": "fail-fast",
      "summary": "Address risks early on in the project.<br />Don't postpone difficult tasks, because they provide you with an <b>opportunity</b> to learn.<br />Tackle them head-on, and get it over with.",
      "description": "<h3>Motivation</h3> <p>Projects fail. That itself is not an problem. In many cases, figuring out if an idea is feasible in the long run would take as much time as giving it a go. So you give it a go, and if fails. Though luck.</p> <p>The big problem however is that projects fail late in the game. That means piles of money were spent on something that - with a little bit of effort - could have been proven to be a failure early on. And that's just plain wrong. Projects should fail as early as possible, if there is a risk it might fail.</p> <p>Edsger Dijkstra once said that whenever he had an idea, he first put in a considerable amount of effort to prove it wrong [citation needed].</p> <h3>Applicability</h3> <p>All projects. But it extends well beyond the boundaries of projects. It also applies to the inner workings of software. If there is a chance it fail, make it fail as early as possible.</p> <h3>Application</h3> • Have a list of risks<br> • Estimate the chance that the risk materializes into a problem<br> • Estimate the cost incurred as a consequence of that problem<br> • Prioritize work to deal with the risks<br> • Make it visible. Having a calendar on the wall that clearly highlights the risks and the moment in time we expected to have dealt with it might help.<br> <br>",
      "category": 4,
      "bitly": "hOXhny"
    },
    {
      "title": "Favor composition over inheritance",
      "url": "composition-over-inheritance",
      "summary": "Also known as the <b>'composite reuse principle'</b>.<br />Favor composition over inheritance to achieve polymorphism.",
      "description": "<h3>Also known as</h3> <p>Composite Reuse Principle</p> <h3>Motivation</h3> <p>When some behaviour of a domain object can change with other features remaining the same.</p> <h3>Applicability</h3> <p>Whenever class hierarchies are being created to specialize behaviour then behaviour could be extracted in an interface. The primary object would delegate the behaviour to interface implementations.</p> <p>This approach avoids the number of classes to be created. Same set of classes composed differently give different run-time behaviour.</p> <h3>Application</h3> <p>Design classes to use interfaces for variable behaviour and delegate the behaviour to a concrete class.</p> <h3>Consequences</h3> <p>Lesser number of classes and multiple behaviour with composition.</p> <p>Extensibility</p> <h3>Samples</h3> <p>If you have different devices that use the same software and only differ in the display hardware. Then you could use two approaches.</p> <h1>Template Method</h1> <pre><code>public class Device { public void display() {    // Basic display }}public class LEDDisplayDevice { public void display() { }}public class ExternalDisplayDevice { public void display() { }}</code></pre> <h1>Using Composition (Strategy Pattern)</h1> <pre><code>public class Device { private Display display; public Device(Display display) {   this.display = display; } public void display() {    this.display.display(); }}public class LEDDisplay { public void display() { }}public class ExternalDisplay { public void display() { }}</code></pre> <h3>References</h3> <p><a href=\"http://www.cs.sjsu.edu/~pearce/cs251b/principles/crp.htm\">Composite Reuse Principle</a></p>",
      "category": 3,
      "bitly": "hzKtcb"
    },
    {
      "title": "Favor continuous improvement over delayed perfection",
      "url": "improve-continuously",
      "summary": "<blockquote><p><b>If you don't get better, you get worse</b>.</p><p>Continuous improvement is not about things you do well - that's work. Continuous improvement is about removing the things that get in the way of your work. The headaches, the things that slow you down, that's what continuous improvement is all about.</p></blockquote><p><em>Bruce Hamilton</em>",
      "description": "<h3>Also known as</h3> <p>At least very much related to Kaizen, or 改善.</p> <h3>Motivation</h3> <p>As the back of the card says, if you don't get better, you get worse.</p> <h3>Applicability</h3> <p>This one is simple: this is always applicable.</p> <h3>Application</h3> <p>In a Scrum process, this is typically what you discuss during the retrospective. You first discuss the things you considered to go well, but then right after that, you talk about the things that could be improved, and then you see to it that you actually take some steps to improve.</p> <p>However, Scrum is not the only context in which this is applicable. It's equally applicable in - say - developing your coding skills. If you are wondering what on earth you could improve in your coding habits and you haven't read the The Pragmatic Programmer or the The Productive Programmer yet, then I'm pretty sure there a couple of things you can learn.</p> <h3>Consequences</h3> <p>Continuous improvement requires dedication, and dedication required dedicated time. It's important that you and your stakeholders agree on the time you are going to claim to improve continuously. Resist the temptation to consider continuous improvement to be something you get for free. Granted, you may be able to weave some improvement into your daily activities without too much cost, but there is a risk you maneuver yourself into a position in which your drive to improve continuously in your work will start hurting you in your private life. Again, continuous improvement is benefiting your stakeholders as well. Make sure that is well understood.</p> <h3>References</h3> • The Programmer's Bill of Rights, Jeff Atwood, <a href=\"http://www.codinghorror.com/blog/2006/08/the-programmers-bill-of-rights.html\">http://www.codinghorror.com/blog/2006/08/the-programmers-bill-of-rights.html</a><br> • The Productive Programmer, Neal Ford<br> • The Pragmatic Programmer; from Journeyman to Master, Andrew Hunt and David Thomas<br> • Kaizen, <a href=\"http://en.wikipedia.org/wiki/Kaizen\">http://en.wikipedia.org/wiki/Kaizen</a><br> <br>",
      "category": 1,
      "bitly": "e1p3oQ"
    },
    {
      "title": "Find the root cause",
      "url": "genchi-genbutsu",
      "summary": "<b>Genchi genbutsu</b> is a Japanese expression for the practice of finding your answers right down at the source.<br /><br />Don't rely on second-hand reports or tables and charts of data to achieve a true understanding. Instead go to the place (gemba) where you can watch, observe, and 'ask why five times'.",
      "description": "<h3>Also known as</h3> <p>現地現物 or \"go and see\", or Gemba attitude, or \"Getcha your boots on\". Gemba is the Japanese term for \"the place\" in this case 'the place where it actually happens'.</p> <h3>Motivation</h3> <p>In order to truly understand a situation one needs to go to 'gemba' or, the 'real place' - where work is done. From Wikipedia:</p> <blockquote>  <p>\"Taichi Ohno, creator of the Toyota Production System is credited, perhaps apocryphally, with taking new graduates to the shop floor and drawing a chalk circle on the floor. The graduate would be told to stand in the circle and to observe and note down what he saw. When Ohno returned he would check and if the Graduate had not seen enough he would be asked to keep observing. Ohno was trying to imprint upon his future engineers that the only way to truly understand what happens on the shop floor was to go there. It was here that value was added and here that waste could be observed.\"</p> </blockquote> <h3>Applicability</h3> <p>This may sound contradictory, but if you are reporting to someone, it doesn't necessarily mean you should be writing lots of reports. The Genchi Genbutsu principle is fairly easy. If one of your managers wants to understand what's going on, he should drop by and take a look at what's happening in the team, rather than expect you to write reports.</p> <h3>Application</h3> <p>First of all, you tell your manager that you are not going to write any reports. Next, make sure that your manager is able to quickly grasp the situation when passing by. Big visible charts come to mind [1]. In any case, getting your manager to understand the situation should take as little effort as possible.</p> <h3>References</h3> • <a href=\"http://essentials.xebia.com/make-it-visible\">Make it visible</a><br> <br>",
      "category": 1,
      "bitly": "fHdeNm"
    },
    {
      "title": "Focus on flow",
      "url": "focus-on-flow",
      "summary": "Focus on banishing costs increases costs.<br />Focus on flow decreases costs.",
      "description": "<h3>Motivation</h3> <p>Wherever software is being built it is done because of an external driver. Typically this driver is a business, although it might also be a personal desire to change the world in some way. It is not generally acknowledged that any effort spent on software development should support this higher purpose. In Lean programs the focus is often on eliminating waste, but it is much more important to improve the flow through the value chain.</p> <h3>Applicability</h3> <p>Whenever you're developing software.</p> <h3>Application</h3> <p>Beware of improving efficiency if the driver is not the business success of the organization. Determine the costs and benefits with respect to the purpose of the software, instead of focusing on the internal cost structure of organization that produces it.</p> <h3>Consequences</h3> <p>When you focus on flow, it means that you're not focusing on keeping middle management happy or keeping your direct colleagues happy. It could cause you to not fit in.</p>",
      "category": 2,
      "bitly": "i9fenO"
    },
    {
      "title": "Get the team in a rhythm",
      "url": "team-rhythm",
      "summary": "A team that works according to a defined heartbeat is much more effective since it doesn't waste time organizing meetings or spend time thinking about and planning what to do when.",
      "description": "<h3>Motivation</h3> <p>How many times a week do we have to go to an unplanned meeting? How often does this disrupt our work? How many meetings are actually useful? How often do these meetings take more than an hour? The answers vary, but typically it is more than 4, they disrupt work every time, next to none are useful, almost always they take more than an hour in discussion. You can become very good at having efficient meetings, but having less meetings is the more effective approach.</p> <h3>Applicability</h3> <p>When a team is struggling to find focus, in many cases improving the rhythm is all that is needed in terms of management.</p> <h3>Application</h3> <p>Useful meetings are those that come at a good time and are about the next thing you should be doing. A standup meeting early in the day can cut down on the time you spend groping around for the best thing to do next. A planning meeting is useful to figure out what the team is going to be doing in the sprint that is about to start. Cut down on all unplanned activities and hold all meetings at fixed times and locations.</p> <p>Apart from forcing a rhythm with meeting schedules, it is very important for the physical and mental health of developers to take regular breaks. It can help a lot to informally synchronize these breaks by taking colleagues to the coffee machine or lunch room.</p> <p>Even if rhythm is very important, pragmatism should not become secondary. Ad hoc design meetings, quick war room meetings, toilet breaks they are all ok to have; being too dogmatic about these things is dangerous.</p> <h3>Consequences</h3> <p>When the team works in a shared rhythm it becomes easier to collaborate and you will see more flow going on. One of the golden rules that follows is that we never move a deadline. Failure is natural, the rejection of a hypothesis is fine. Moving a deadline often means the prolongation of a failed attempt.</p> <h3>Samples</h3> <p>A team we coached at one of our clients got in trouble. They had underestimated some work and decided to push all user stories at the same time in an all or nothing attempt and failed to deliver anything demoable at the end of the sprint. Then management agreed to not have the retrospective and planning meeting and just carry on for one more week. At the end of that week it turned out that most of the functionality was not according to the expectations. Not only did the team fail the previous sprint, but they also failed to properly plan this one. As a result two sprints were lost instead of one. The worst effect however was that the team got out of their rhythm and continued to have lower productivity and decreased motivation in the subsequent sprints.</p>",
      "category": 2,
      "bitly": "gfk6pL"
    },
    {
      "title": "Have fun",
      "url": "have-fun",
      "summary": "If it ain't <b>fun</b>, it probably ain't right.",
      "description": "<h3>Also known as</h3> <p>If it ain't fun, it probably ain't right.</p> <h3>Motivation</h3> <p>Having fun in work is a big deal when it comes to the creative process that is software engineering (or engineering in general). There will always be tasks that are less fun. Performing those tasks first will make you look forward to the fun tasks.</p> <h3>Applicability</h3> <p>This rule is applicable at work as well as in your private life.</p>",
      "category": 2,
      "bitly": "f37zxa"
    },
    {
      "title": "If it hurts, do it more often",
      "url": "hurt-often",
      "summary": "If any particular task, such as deployment to production, takes inordinate effort, force yourself to <b>streamline the process</b>.",
      "description": "<h3>Motivation</h3> <p>Formally, you have a quarterly deployment to production. Informally, the last three attempted deployments caused so much unforeseen problems and downtime that no amount of testing is now enough to confidently deploy. Key stakeholders book their vacations so as to not be around at release time. Getting sign-off takes months. Releases are cumulative, so each missed release increases the risk of the next one. The last five release windows were missed because of this. The organization is paralyzed, no code has made it to production in over a year.</p> <h3>Applicability</h3> <p>The scenario above is extreme, but not unheard of. If any particular task is so daunting that it gets delayed to mitigate risk, an organization may end up in a downward spiral that completely stalls its software delivery. When this occurs, it is often, but not exclusively, in the final step of deploying to production.</p> <h3>Application</h3> <p>The most effective antidote is radical exposure therapy. Force your organization to perform the stalling task at an increasing pace that quickly becomes impossible unless the process is fixed. This hurts, this will initially fail, but tightening the schedule works in two ways: it reduces the scope of each iteration (thus making it easier to manage) and it increases the pace at which you learn from and adapt to the problems that occur.</p> <h3>Consequences</h3> <p>Shortening your time to production increases your ability to respond to change and, ultimately, your competitiveness. There's no upper bound, internet giants like Facebook and GitHub successfully deploy to production hundreds of times per day.</p> <h3>References</h3> • Related Cards: <a href=\"http://essentials.xebia.com/three-strikes\">Three Strikes and you Automate</a>, <a href=\"http://essentials.xebia.com/integrate-early\">Integrate Early</a>, <a href=\"http://essentials.xebia.com/run-tests-automatically\">Run Tests Automatically</a><br> • <a href=\"https://github.com/blog/1241-deploying-at-github\">Deploying at GitHub</a><br> • <a href=\"http://martinfowler.com/books/continuousDelivery.html\">Continuous Delivery</a><br> <br>",
      "category": 2
    },
    {
      "title": "If something is too complex to understand, it must be wrong",
      "url": "poutsma-principle",
      "summary": "...and it's your job to prove it wrong.<br />Also known as the <b>'Poutsma Principle'</b>.",
      "description": "<h3>History</h3> <p>Originally used as a joke between Spring developers. Arjen Poutsma originally formulated the principle as:</p> <blockquote> <p>If something is too complex for me to understand it must be wrong</p> </blockquote> <p>The card was reformulated to be more generally applicable. Note the correspondence with a famous quote from Calvin and Hobbes:</p> <blockquote> <p>As far as I'm concerned, if something is so complicated that you can't explain it in 10 seconds, then it's probably not worth knowing anyway.</p> </blockquote> <h3>Motivation</h3> <p>Sticking to this principle means that you will not allow things that you don't understand to survive. In some cases, the exercise of proving something wrong will result in understanding rather than proof, in some cases it will simply result in proof.</p> <h3>Applicability</h3> <p>Use this principle to attack parts of the code base that are no go areas or considered dangerous to change based on no apparent good reasons. The principle can also be applied to processes and rules in organizations to help them change.</p> <h3>Application</h3> <p>Write a test case. In an organization rather than a code base your only weapon is reason, so you have to create a solid argument that proves the complexity is in fact wrong.</p> <h3>Consequences</h3> <p>Not allowing complexity to remain unchallenged takes time and effort. We cannot attack all problems that we encounter. It is better to challenge one thing fully then to challenge many things but failing to provide any proof. This means that a few complexities will be taken out, and some are left for another day.</p> <h3>Samples</h3> <p>In the early days of Spring Integration developers struggled with the model of allowing both chains of endpoints and connections between endpoints through channels. We also had DirectChannel that worked both ways (send and receive). This meant that we had channels implementing MessageSource and MessageTarget and endpoints implementing similar interfaces. Through the application of the original Poutsma principle we ended up with a simple and clear solution: anything in the framework is related to either a Message, an Endpoint, or a Channel.</p> <h3>References</h3> <p>Related Cards: <a href=\"http://essentials.xebia.com/kiss\">Keep It Simple</a></p>",
      "category": 3,
      "bitly": "eG5fsb"
    },
    {
      "title": "If you are stuck developing for more than two minutes, you MUST ask somebody else",
      "url": "two-minute-rule",
      "summary": "It's not professional to waste time by trying to solve something on your own that is quicker <b>solved with help</b>.<br /><br />You know you're stuck when you can't think of new terms to type into Google.",
      "description": "<h3>Also known as</h3> <p>Stop the stubborn \"I wanna figure it out myself\", ask for help!</p> <h3>Motivation</h3> <p>You know the situation. Your co-worker does not use the keyboard anymore, and looks worried. There is a lot of sighs. Nothing happens. Then there is \"Google to the rescue\". Evidently, someone is trying to solve some problem, but is simply stuck. Everyone knows that just explaining the problem to others frequently helps to solve the problem on the spot! In other cases, there are other team members that have the solution ready at hand.</p> <p>Think about the implication to the team's output. You are wasting time. Velocity drops. You can learn, but faster! Ask other team members to help!</p> <h3>Applicability</h3> <p>This idea is crucial to us for two reasons:</p> • it eliminates waste, as in many situations the knowledge needed to solve the problem at hand is already present in the team.<br> • it amplifies learning, as the more knowledgeable workers have to teach the less knowledgeable ones.<br> <br> <h3>Application</h3> <p>Watch you fellow team members as they are working. It is easy to spot the situation. Your co-worker does not use the keyboard anymore, and looks worried. Then simply ask: \"Hey! What are you thinking about? You are too quiet!\" This will spawn the appropriate discussion. For real.</p> <h3>Consequences</h3> <p>The result of applying this idea in practice is that your team will go into team-learning mode. The \"heroes\" teach the \"wannabe-heroes\". Knowledge is shared.</p> <h3>Samples</h3> <p>Teams trying to apply this idea sometimes fall into the following pit. The more knowledgeable person pushes the less knowledgeable away from the keyboard in a \"OMG let me just do it\" style. Fight this attitude. Get the more knowledgeable one into \"teaching-mode\". Be aware: this might be hard.</p> <h3>References</h3> <p>Related Cards: <a href=\"http://essentials.xebia.com/eliminate-waste\">Eliminate Waste</a>, <a href=\"http://essentials.xebia.com/team-member-equality\">Everybody in a project team is equal</a>, <a href=\"http://essentials.xebia.com/pair-programming\">Pair programming</a>.</p> <p>Relevant literature: Mary and Tom Poppendieck: \"Lean Software Development: An Agile Toolkit.\"</p> <p>Akamai uses a <a href=\"https://blogs.akamai.com/2013/10/you-must-try-and-then-you-must-ask.html\">fifteen-minute rule</a>.</p>",
      "category": 1,
      "bitly": "fmam2x"
    },
    {
      "title": "Improve practices, don't just follow the recipe",
      "url": "context-over-habit",
      "summary": "With all 'best practices', principles and experience, you should always keep an eye on the context: does what used to work there and then work here now? Keep thinking, keep looking.",
      "description": "<p>All \"Best Practices\", principles and experience are rooted in a certain context. What worked then and there may not work here and now. You can take pretty much any accepted best practice, change the context around it, and turn it into the worst thing you could have possibly done. Don't make a choice by default, don't do what you always did. Don't follow advice, no matter how well intentioned, without thinking about the consequences. <a href=\"http://essentials.xebia.com/dare-to-say-no\">Don't walk off a cliff</a> because someone in a position of authority told you to. Pick an appropriate solution for the problem at hand. Pick a <a href=\"http://essentials.xebia.com/improve-continuously\">better solution</a> than the one you used last time.</p> <p>The appropriate solution may of course be a common Best Practice. They're called that for a reason. Just think when you apply one.</p> <h3>References</h3> • <a href=\"http://blogs.tedneward.com/2005/08/26/There+Is+No+Such+Thing+As+Best+Practices+Context+Matters.aspx\">There is no such thing as best practices</a>, Ted Neward's blog.<br> <br>",
      "category": 1,
      "bitly": "hNswdJ"
    },
    {
      "title": "Integrate early",
      "url": "integrate-early",
      "summary": "The point where two independently developed modules or systems meet tends to be the locus of problems. Tackle these early on.",
      "description": "<h3>Motivation</h3> <p>It's not uncommon for two connected systems to be developed completely independently, sharing only an interface definition. Time and again, it turns out that the development teams involved interpret the same spec subtly (or wildly) differently. Furthermore, teams have a tendency to delay actually tying the two systems together to the very last moment (\"it's not ready yet!\"). Inevitably, the systems turn out not to fit together without modification and a lot of stress, finger pointing and bad language ensues.</p> <h3>Applicability</h3> <p>Applies on any boundary between two independently developed systems or subsystems.</p> <h3>Application</h3> <p>Instead of agreeing on a spec and parting ways, realize the interface as early as possible, backed by as much stubbing and gaffer tape as needed. Coordinate between teams on the order in which the different facets of the interface are fleshed out and on any interface changes that emerge. Run automated integration tests that touch the other system. Going live in production should be a first anniversary, not a first date.</p>",
      "category": 3
    },
    {
      "title": "It ain't over till it's done",
      "url": "done",
      "summary": "Create a <b>clear definition of DONE</b> to have a firm agreement on whether a task is finished or not.",
      "description": "<h3>Motivation</h3> <p>Have you ever come across the situation when you walked up to the story wall, picked up your story and proudly moved it to Done state? Moments later, the tester comes to you and asks \"is it deployed on the Test server, so that I can test that?\", the Scrum Master asks \"has that shown to the Product Owner?\" Another dev asks \"are there still pending tests cases to commit 'cause I see some of them missing here\". And you response was probably: \"No\"?</p> <p>Scrum provides the Definition of DONE (DoD), which is a shared checklist of criteria for a story to be considered DONE. Tasks in the definition are mutually agreed between the development team and the Product Owner.</p> <h3>Applicability</h3> <p>Definitions of DONE can be applied to any business or technical story and may differ a bit in different kinds of activities. There may be multiple Definitions of DONE for different sorts of activities, although you should try to keep things simple; in many cases it will suffice to just skip a step as \"not applicable\". For example, a Refactoring technical story done as a part of removing technical debt may not be showcased to the Product Owner.</p> <h3>Application</h3> <p>DoD can be put as points on a sheet of paper against your story wall. In teams using a digital wall such as Mingle, ScrumWorks, GreenHopper or Rally, it is generally put up in the wiki and cross referenced when a story is completed.</p> <p>The sprint retrospective is a good time to check if the prevailing Definition of DONE needs to be amended or updated.</p> <h3>Consequences</h3> <p>The definition of done prevents unpleasant, last minute surprises. It puts everyone on the same page. It also leads to better story estimation because you don't just estimate for the lines of code to make that feature working but other things as well.</p> <h3>Samples</h3> <p>Sample definition of DONE:</p> <p>Have all the <a href=\"http://essentials.xebia.com/acceptance-criteria\">acceptance criteria</a> implemented as specified in the story. Sufficient unit test around the code (let's say 80%). Code's <a href=\"http://essentials.xebia.com/code-review\">peer review</a> is done if necessary. The story is deployed on the testing environment using CI. The story is <a href=\"http://essentials.xebia.com/done-is-live\">deployed in production</a>. Functional tests are written for the story. Story is signed off by the product owner.</p> <h2>Related cards</h2> • <a href=\"http://essentials.xebia.com/code-review\">Code Review</a><br> • <a href=\"http://essentials.xebia.com/test-everything\">Test Everything</a><br> • <a href=\"http://essentials.xebia.com/done-is-live\">Done is Live</a><br> • <a href=\"http://essentials.xebia.com/brutal-transparency\">Brutal Transparency</a><br> <br>",
      "category": 2,
      "bitly": "eRw2Hq"
    },
    {
      "title": "Judge on content, not on authority",
      "url": "team-member-equality",
      "summary": "We distinguish on the validity of the <b>ideas</b>, not on roles, authority or location.",
      "description": "<h3>Also known as</h3> <p>One team.</p> <h3>Motivation</h3> <p>We distinguish on the validity of the ideas, not on roles, authority or location.</p> <p>Every member of a team has special skills that add to the success of the project or product. Werther it be the analytical skills of the business analyst, the out of the box way of thinking of the tester or the tool knowledge of the programmer.</p> <h3>Consequences</h3> <p>Learn from each other. Respect each others opinions.</p>",
      "category": 2,
      "bitly": "hPhC0V"
    },
    {
      "title": "Keep the build clean",
      "url": "clean-build",
      "summary": "<blockquote>The build logs should tell a <b>clear story</b> about failures, errors, but also warnings.",
      "description": "<h3>Also known as</h3> <p>Aim to keep the build clean.</p> <h3>Motivation</h3> <p>When we start a new project from scratch, the build is clean and initially there are no warnings, no problems. As the code base grows, we start to see warnings in the build log. If we don't pay attention, the warnings start piling up.</p> <p>When there's a lot of noise, it's much harder to find the warning that I really want to read among the hundreds of warnings I don't care about.</p> <h3>Applicability</h3> <p>Whenever you build the code.</p> <h3>Application</h3> <p>Don't wait for a pile of warnings before you start cleaning up. The moment the warnings are seen, deal with them to ensure that they don't turn up into noise very soon.</p> <h3>Consequences</h3> <p>Warnings from the build are useful. To get the focus on to the warnings, it is essential to get rid of the noise. If the build has little or no noise, it is easy to spot a new warning easily.</p> <p>It is easier for someone to take over my work, if the build is clean. My successor won't have to wonder if any warning is to be ignored or fixed.</p>",
      "category": 1,
      "bitly": "gSzxew"
    },
    {
      "title": "Keep your hands off the machine",
      "url": "hands-off-machine",
      "summary": "Stop manual changes and <b>automate</b> the installation and configuration of the server: from operating system to middleware and applications.",
      "description": "<h3>Motivation</h3> <p>Operating systems and middleware and managed and maintained manually. Changes can only be made by system administrators and operators through a formal change procedure. This makes any change slow due to the hand-offs and error prone. As it is a lengthy process, developers are often given more privileges on development and test machines to experiment with changes to middleware or operating system configurations. As these changes are often forgotten in the installation instructions for QA and production environments, errors popup that were solved in the developer maintained environments.</p> <h3>Applicability</h3> <p>Anywhere, where multiple machines are managed manually this principle is applicable.</p> <h3>Application</h3> <p>Automate the installation and configuration of the machine, the operating system and the middleware by using tools like Puppet, Ansible, Salt Stack or Chef. Remove the need to login to the machine by providing everything that is needed to develop and run an application:from easy access to the log messages, application health dashboard, control of the application deployments and the ability to restart the application servers.</p> <h3>Consequences</h3> <p>Configuration drift between environments will be eliminated, The cost of system maintenance will dramatically be reduced and you will end up with more stable environments.</p>",
      "category": 3
    },
    {
      "title": "Keep your logs clean",
      "url": "clean-logs",
      "summary": "<b>Log everything you need, but nothing more:</b><br /><br /> • Log at the right level<br /> • Log every message once<br /> • Categorize if needed<br /> • Throw meaningful exceptions<br /> • Don't cry wolf<br />",
      "description": "<h3>Motivation</h3> <p>Logging is one of those deceptively simple concerns. “How hard can it be?”</p> <h3>Applicability</h3> <p>Logging is a very common <a href=\"http://essentials.xebia.com/non-functionals\">requirement</a> that tends to get not much thought unless the logging volume is huge.</p> <h3>Application</h3> <h1>Log at the right level</h1> <p>Establish (and follow) a common convention for assigning event priorities.</p> <p>For example, use the INFO level to report the actual (as used) configuration settings during start-up and inform of system status changes such as \"Started successfully\" or \"Shutdown initiated by  <admin name=\"\">   \". Use the WARNING level to report things that a developer or operator should look at, but that don't threaten the immediate operation. Use the ERROR level to report things that need immediate action, such as an unreachable database or a backed up message queue. Use the DEBUG level for everything else. You should be able to tie a pager to ERROR events and not lose sleep over trivialities, nor miss out on fatalities (mind you, alerting is hard).  </admin></p> <h1>Log every message once</h1> <p>Anything more than that adds confusion and wastes disk space. It's quite common for exceptions to be logged more than once. Avoid this if you can.</p> <h1>Throw meaningful exceptions</h1> <p>An exception message in your log file is of no use if it doesn't help you figure out what's wrong. Use a clear message and provide context. Use custom exception types so that different groups of problem types can be handled separately in different catch blocks.</p> <h1>Keep auditing information separately</h1> <p>The audit trail should have its own, dedicated destination (log file, database, what have you). The audit trail may have different archiving demands than the application log file.</p> <h1>Don't cry wolf</h1> <p>If your log file raises a lot of false alarms, it will get ignored and any real problems won't become apparent until the phones start ringing.</p> <p>Don't put yourself in a position where you have to say \"Please ignore those exceptions you see in the logs, they are normal\". An exception stack trace stands out like a sore thumb in any log file. If you work with functional exceptions, you have to catch them and handle them in a way they do not appear in your technical logs.</p> <h1>Allow tuning of a running system</h1> <p>For long running systems, embed some troubleshooting tools, like the ability to generate more verbose logging; possibly tied to a specific user session.</p> <h3>References</h3> <p>Code complete, 2nd Edition. Steve McConnell, Microsoft Press.</p>",
      "category": 4,
      "bitly": "h8r0nQ"
    },
    {
      "title": "Learn a new language every year",
      "url": "learn-a-new-language",
      "summary": "Learning a new language teaches you new concepts that will benefit you when programming in your main language.",
      "description": "<h3>Motivation</h3> <p>Each programming language is different. There are the obvious differences in language family, such as Object Oriented or Functional, but even within families, the differences are large: Objective C looks nothing like Java and the difference goes well beyond the superficial. Every programming language you learn teaches you new ways of reasoning about the task at hand. This experience carries over into other programming language, strengthening your ability in all of them. And it's fun!</p> <h3>Application</h3> <p>To learn a language, you need to go beyond \"Hello, World!\", but rewriting your day job from scratch may be a bit optimistic. Build Conway's game of life or a Sudoku solver. Build a TODO tracker or Twitter client. Contribute to an open source project.</p>",
      "category": 1
    },
    {
      "title": "Leave the campground cleaner than you found it",
      "url": "boy-scout-rule",
      "summary": "Also known as the <b>Boy Scout Rule</b>, after the Boy Scouts of America.<br />Applied to programming: Always check in code in a cleaner state than when you checked it out.",
      "description": "<h3>Motivation</h3> <p>Known as the Boy Scout Rule, (possibly) first introduced by the Boy Scouts of America. This simple rule that works great for camping in nature can also be applied to programming: when you're done with a task, always check in code in a cleaner state than when you checked it out.</p> <h3>Applicability</h3> <p>This should be daily routine for a software engineer. Make sure you do not pollute your regular commits with clean up actions.</p> <h3>See also</h3> • <a href=\"http://essentials.xebia.com/one-change-at-a-time\">one-change-at-a-time</a><br> • <a href=\"http://essentials.xebia.com/no-museum\">no-museum</a><br> <br>",
      "category": 1,
      "bitly": "hIOozD"
    },
    {
      "title": "Make it visible",
      "url": "make-it-visible",
      "summary": "The most effective way to get a message across is by <b>visualizing it</b>. Use simple charts and diagrams in favor of spreadsheets, and pictures instead of prose.",
      "description": "<h3>Also known as</h3> <p>At least related: Big Visible Charts</p> <h3>Motivation</h3> <blockquote>  <p>\"There is no more powerful way to prove that we know something well than to draw a simple picture of it. And there is no more powerful way to see hidden solutions than to pick up a pen and draw out the pieces of our problem.\"</p> </blockquote> <p>– Dan Roam, The Back of a Napkin</p> <p>A burndown chart is the perfect example of a visualization that allows you to understand in a glance where the team is heading. It's questionable if a picture really says more than a thousand words (I personally think a thousand words actually say more), but a proper visualization does a much better job capturing the essence.</p> <h3>Applicability</h3> <p>Visualization is a tool that comes in handy in all sorts of circumstances. Dan Roam cuts the problem solving process into four phases, and suggests visualization techniques to help you through each of these phases:</p> • Looking = Collecting and screening<br> • Seeing = Selecting and clumping<br> • Imagining = Seeing what isn't there<br> • Showing = Making it all clear<br> <br> <h3>Application</h3> <h2>Don't hesitate</h2> <p>First of all, if you are convinced that you have a way of using visualization to show what's out there, to reveal patterns, to compare some ideas or to sell a particular one, then you don't hesitate; you just do it. For some people, that's harder than others. However, Dan Roam is convinced everyone can do it. All you need to be able to do is draw a line, draw a circle, a face and some arrows.</p> <h2>Where to start</h2> <p>If you don't know where to start, it might be good to check the Visual Thinking Codex. It offers suggestions on the kind of pictures to use in various circumstances.</p> <h2>Stick it on the wall</h2> <p>A visualization is not going to be helpful at all if it sits somewhere on a network drive. It should be out there in the open, for everyone to see. Don't hesitate to use the space surrounding you or your audience. Stick it on the wall, plaster the elevator, be creative.</p> <h2>Hand-drawn, informal and casual</h2> <p>Consider casual, hand-drawn, informal and even messy in favor of smooth, formal, polished and tool generated. There are many reasons why. First of all, in most cases, jotting something down by hand is just going to be way faster than by using a tool. If a hand-drawn picture tells as much as a tool-drawn picture, then spending hours on getting something fancy is just waste.</p> <p>Other than that, hand-drawn, informal and improvised pictures are often easier to remember than cold, formal and tool-generated diagrams.</p> <p>And last but not least, collective design efforts result in hand-drawn, informal and improvised type of diagrams any way. At the end of a collective design effort, when there is consensus on how to move forward based on an informal diagram drawn on a whiteboard, what would be the value of turning it into a formal diagram. The hand-drawn diagram is still imprinted on everyone's retina. Chances are that turning it into a formal diagram is only going to make it harder for people to understand.</p> <h2>If you want tools any way</h2> <p>Here are some of the tools we use:</p> • Omnigraffle: informal but pretty.<br> • Graphviz: not that pretty, but extremely convenient in taking care of the heavy-lifting.<br> • Google Visualization API: pretty decent, again very convenient for preventing you from having to manually draw the same diagram over and over again.<br> • Protovis: if you are into automating things, then Protovis draws awesome pictures, but it might be a little harder to use than - say - Google visualizations.<br> • Raphael: if neither Google nor Protovis support the kind of diagrams you want to generate, Raphael is your next best option.<br> <br> <h3>References</h3> • The Back of a Napkin, Dan Roam<br> • Gapminder, <a href=\"http://www.gapminder.org/\">http://www.gapminder.org/</a><br> • Notation and Representation in Collaborative Object-Oriented Design, Uri Dekel and Herbsleb<br> • Protovis, <a href=\"http://vis.stanford.edu/protovis/\">http://vis.stanford.edu/protovis/</a><br> • Google Visualization API, <a href=\"http://code.google.com/apis/charttools/index.html\">http://code.google.com/apis/charttools/index.html</a><br> • Raphaël, <a href=\"http://raphaeljs.com/\">http://raphaeljs.com/</a><br> • The Visual Thinking Codex_, Dan Roam, <a href=\"http://www.thebackofthenapkin.com/pdf/TBOTN_codex.pdf\">http://www.thebackofthenapkin.com/pdf/TBOTN_codex.pdf</a><br> <br>",
      "category": 2,
      "bitly": "h0b8NA"
    },
    {
      "title": "Make it work Make it right Make it fast",
      "url": "make-it-work-right-fast",
      "summary": "To prevent <b>analysis paralysis</b>, follow these simple steps in case a problem seems too big to tackle.<br />First simply make it work. Second, make it right, by making your code compliant with craftmanship principles.<br />Finally, make it fast if really needed.",
      "description": "<h3>Motivation</h3> <p>To prevent analysis paralysis, follow these simple steps in case a problem seems too big to tackle.</p> <p>First, simply make it work. Don't pay (much) attention to craftsmanship principles such as <a href=\"http://essentials.xebia.com/dry-principle\">dry</a>.</p> <p>Second, make it right, by making your code compliant with craftsmanship principles.</p> <p>Finally, make it fast if really needed.</p>",
      "category": 1,
      "bitly": "hnENEg"
    },
    {
      "title": "Make room for exploratory testing",
      "url": "exploratory-testing",
      "summary": "Following a test script means you're <b>consistent, but predictable</b>. Exploratory testing reveals the things you hadn't thought to script. Be curious, go outside the beaten path.",
      "description": "<h3>Motivation</h3> <p>Users tend to use an application in unexpected ways. Conventional happy path testing is not sufficient. Event with failure path testing only a subset of the possible ways to work your way through an application are tested.</p> <p>Exploratory testing is a disciplined method to test (corner) cases in the application.</p> <h3>Applicability</h3> <p>Listen to your curiosity Define what you're curious about and explore ASAP.</p> <h3>Application</h3> <p>Despite the \"exploratory\" nature of the tests, it is required to do some preparation upfront. The expedition should be prepared, you have to define a goal of the exploration. No need to wander of the path: take notes about alternative paths that can be investigated in future expeditions.</p> <h3>Consequences</h3> <p>Parts of the system, or flows through the system, that are not commonly checked are tested. Possible issues can be resolved and tested with automated tests.</p> <h3>Samples</h3> <p>Create a simple Test Charter Card which describes your curiosity with the following format:</p> <p>Explore: A target With: Resources To Discover: Information</p> <p>By target we mean: What are you exploring? e.g. UI input fields, Login pages or XML responses? By resources we mean: What resources will you be using? e.g. JavaScript / SQL injection or Spoofed URLs &amp; POSTS Information: What kind of information are you hoping to find? e.g. Can an user access content which they are not allowed to access or any other security vulnerabilities</p> <h3>References</h3> <p><a href=\"http://pragprog.com/book/ehxta/explore-it\">http://pragprog.com/book/ehxta/explore-it</a></p>",
      "category": 4
    },
    {
      "title": "Master your tools",
      "url": "master-your-tools",
      "summary": "Expect unprecedented productivity gain when investing time in mastering your tools. Tools will help you to:<br /><br /> • Accelerate<br /> • Focus<br /> • Avoid repetitive tasks<br /> • Eliminate duplication<br /><br />Tools include your IDE, commandline tools, desktop tools, editors, etc.",
      "description": "<h3>Motivation</h3> <p>As software developers we use a huge variety of tools, from the very simple to the immensely complex. It takes considerable effort to learn to make the most of these. This is effort well spent.</p> <h3>Applicability</h3> <p>All the time. There is no one tool that serves all your needs though. Pick tools that suite your needs. Do not go for the most complex tools directly.</p> <h3>Application</h3> <p>Just do it. Start looking up the keystrokes for frequent tasks and memorise them.</p> <p>How about a command line tools? Not having to lift your hands of the keyboard can be a great time saver.</p> <h3>Consequences</h3> <p>A huge increase in productivity, fewer keystrokes, colleagues who gasp and stammer \"how did you do that?\".</p> <h3>Samples</h3> • Learn the keystrokes for your language IDE by heart. Twice. Master its search and navigation functions. Optimize the syntax highlighting to your preferences.<br> • As an example of the latter: Eclipse JDT defaults to using italic font for static members and no highlighting for abstract members. Bring these in line with UML and underline your statics, italicize your abstracts. Now you can see an abstract method invocation and know not to press F3 (which uselessly takes you to the declaration), but CTRL-T to take you to an implementation.<br> • Learn to use at least one command shell and its scripting language for every platform your frequently use. Learn a text editor for that shell. Unix is traditionally stronger than Windows in this area, although Windows PowerShell should not be underestimated. You can mix and match! Bash, vim, wget and xmllint are all avaiable on Microsoft Windows and work perfectly fine. By installing these your can focus your effort on just one type of shell.<br> • Learn to use SSH login by a private key protected with a passphrase instead of a password entered at shell login. Manage private keys on your workstation using ssh-agent (or pageant).<br> <br> <h3>References</h3> <p>If you're into vi (a unix text editor), try http://vimgolf.com.</p>",
      "category": 1,
      "bitly": "fmYabp"
    },
    {
      "title": "Maximize cohesion Minimize coupling",
      "url": "maximize-cohesion-minimize-coupling",
      "summary": "Maximizing cohesion and minimizing coupling reduces complexity and increases testability.",
      "description": "<h3>Motivation</h3> <p><em>Coupling</em> is the degree to which each program module relies on each one of the other modules. So, coupling is all about the relation between modules. Tightly coupled systems have a number of undesirable properties:</p> • Changes in one module tend to have a ripple effect on other modules. (So it's hard to make isolated changes.)<br> • It will be hard to test a module in isolation.<br> • It will be hard to reuse a module in an alternative context.<br> <br> <p><em>Cohesion</em> is a measure of how strongly-related or focused the responsibilities of a single module are. Systems with minimal cohesion have a number of undesirable properties:</p> • (When applied to source code) code tends to be less readable.<br> • Code is likely to be less reusable in alternative contexts.<br> • Complexity is high. (It's hard to figure out what belongs where and why.)<br> <br> <p>As a consequence, you should <em>minimize</em> coupling and <em>maximimze</em> cohesion when designing your modules.</p> <h3>Applicability</h3> <p><em>Minimal coupling</em>, <em>maximal cohesion</em> is applicable to many contexts. Traditionally, it's often associated to source code level design practices, but it is by no means restricted to that context. Many people have argued that it is equally applicable in enterprise scale problems[2], and I have no problem considering it applicable to hardware design as well. The standardization of USB, PCI, memory modules - it all seems to be driven by a desire to minimize coupling (allowing us to use it in many contexts) as well a maximizing cohesion (this piece of hardware serves one function only).</p> <h3>Application</h3> <p>In order to maximize cohesion, make sure you are always able to summarize the purpose of a single module in a single phrase. If it turns out to be impossible to capture the purpose of a module into a single discriminative phrase, then that's a smell. At the other hand, don't go totally overboard by making everything a separate module; it will have a dramatic effect on the number of dependencies between modules, and therefore hurt you in terms of coupling.</p> <p>One of the tools that might help you organizing your dependencies is the Dependency Structure Matrix.</p> <h3>Consequences</h3> <p>Applying this principle makes it more likely that pieces of your software will survive over time.</p> <h3>References</h3> • Structured Design, W. Stevens, G. Myers, L. Constantine, IBM Systems Journal, 13 (2), 115-139, 1974.<br> • Simple Architectures for Complex Enterprises, R. Sessions, Microsoft Press, 2008<br> <br>",
      "category": 3,
      "bitly": "euvBUZ"
    },
    {
      "title": "No blame, but no mercy",
      "url": "no-blame-no-mercy",
      "summary": "Make mistakes, feel obliged to learn from them. Look back and learn from what you're doing; actively improve. Criticize bad code, don't criticize people.<br />Fix it and <b>share what you've learned</b>.",
      "description": "<p>Bad program code is actively harmful. It's not just that a specific piece of functionality is flawed and/or hard to maintain. Badness tends to spill over into the surrounding code, because maintainers get confused, demotivated and/or frustrated into producing more of it. This is known as “Bit Rot”. Developers should [not feel comfortable|no-broken-windows] around bad code.</p> <p>All bad code has an author, or authors as the case may be. It's tempting to associate the author with the code. Don't. We criticize bad code, we don't criticize people. Fix the code, discuss the problem with the team and show them how it can be done better. Prevent the same sort of badness from entering the system again.</p> <p>This approach yields multiple benefits: better code, fewer repetitive mistakes, more knowledge exchange.</p>",
      "category": 2,
      "bitly": "dYMaJJ"
    },
    {
      "title": "No broken windows",
      "url": "no-broken-windows",
      "summary": "If something is broken, then <b>fix</b> it now, otherwise it will come back to haunt you in the future.",
      "description": "<h3>Also known as</h3> <p>Broken windows theory</p> <h3>Motivation</h3> <p>Broken windows theory is originally a criminology theory that couples the crime rate of a neighborhood to how well maintained and orderly it is. Psychologically we are less inclined to make a mess when everything around us is pristine and orderly</p> <p>The same applies to our software development. When the entire codebase is orderly, it is more likely to stay that way. When it is a mess, we easily feel like it is permitted to cut corners and deliver sloppy work.</p> <p>In order to stick to our standards of quality without compromise it is therefore necessary to keep all our code clean, and leave no 'broken windows'.</p> <p>Apart from the psychological benefit, this also has the technical benefit of keeping technical debt to a minimum, enabling us to keep focus on adding value, instead of cleaning up messes from the past.</p> <h3>Applicability</h3> <p>All our engineering work.</p> <h3>Application</h3> <p>In practice this means that we do not leave 'todos' undone in our code. We want the codebase to be fully in order, and use our own sense of professionalism and aesthetics to determine when something is good enough. We also implement a full test harness and take our time to do things the right way. That means that we do not skip on documentation or refactoring. There is only one way to do things, and that is with all these included.</p> <h3>Consequences</h3> <p>By keeping our technical debt low, we keep ourselves to a high technical standard and achieve maximum productivity, speed and maintainability or our software.</p> <h3>Samples</h3> <p>Everyone has worked on projects in the past where the technical standard was not uniform and corners were cut under pressure of time. Those projects typically get bogged down in a swamp of technical debt, with developers going into hacking mode. The productivity drops in only a few weeks, and only a few heroes are able to make sense out of the spaghetti that has been created. Overall we do our clients a disservice by giving in to pressure to cut corners.</p> <h3>References</h3> <p><a href=\"http://en.wikipedia.org/wiki/Broken_window_theory\">http://en.wikipedia.org/wiki/Broken_window_theory</a></p>",
      "category": 2,
      "bitly": "h1Bm7v"
    },
    {
      "title": "No change without a failing test",
      "url": "no-test-no-bugfix",
      "summary": " • Don't fix a bug before you have a broken test<br /> • A feature is only considered done once you have tests for it<br /> • Don't refactor before you have sufficient test coverage",
      "description": "<h3>Motivation</h3> <p>If it ain't broke don't fix it goes the old saying. This is often used to resist changes, but resisting change isn't all bad. In fact, changes are risky and should only be done if there is sufficient reason. A broken test case is proof of a bug (if the test case makes sense) and demanding reproducible breakage before undertaking a risky change is a good recipe to avoid awkward discussions.</p> <h3>Applicability</h3> <p>Before you do anything you should have a reason. Especially in a situation where you will potentially be held accountable for your actions having a good reason for them is essential. Proving that something is broken before you fiddle with it is mandatory, in code this means changing or creating a test first and only then changing the code. There is still some discussion on the effectiveness of test driven development. Measurements are not entirely conclusive, suggesting that there are situations where test driven development is not applicable. We suggest to at least ensure there is an objective way to verify the results of the change (keeping some leeway in the method).</p> <h3>Application</h3> <p>Whenever we attempt a change, we first figure out if we can prove that we've succeeded when we are done with our change. Once we have a method to prove if our change was successful we carry on. In the process we strive to leave an automated solution to make sure our change is never broken unintentionally. This is often but not always done through a unit test.</p> <h3>Consequences</h3> <p>Acting this way results in higher code coverage and more sensible test cases. It may sometimes require extra effort to get started with a change.</p> <h3>Samples</h3> <p>In a large code base of a longer running project a bug was logged on some parsing issue. A developer went into the code and changed the parser to deal differently with a certain character. A few weeks later another parsing issue was logged; another developer went in and changed the logic back. Both developers saw from the single example in the issue that their fix would solve the problem for the particular example. Then the first bug was reopened and the first developer got furious, reverted the change that removed the check and committed. Then a bit later the second bug was reopened. If only they both had created test cases there wouldn't have been a problem at all.</p> <h3>References</h3> • <a href=\"http://www.researchgate.net/publication/3188484_On_the_effectiveness_of_the_test-first_approach_to_programming\">On the Effectiveness of Test-first Approach to Programming</a> Hakan Erdogmus, National Research Council Canada.<br> <br>",
      "category": 1,
      "bitly": "fMf3Lo"
    },
    {
      "title": "No multitasking",
      "url": "no-multitasking",
      "summary": "Doing multiple things at once will lower your productivity instead of raising it.<br /><br />Try, as much as possible, to focus on one thing at a time.<br /><br />To do great work, you need great focus.",
      "description": "<h3>Motivation</h3> <p>Your brain does not handle multitasking as well as you think. Enhance your productivity by focusing completely on one task at a time.</p> <h3>Application</h3> <p>Resisting distractions requires some discipline. There are many things you can do to make it easier:</p> <p>Auto-hide your taskbar or dock. Close (or at least mute) your email and IM clients. Establish \"no distraction\" times in your team. If you tend to procrastinate, consider a service like RescueTime. If you are easily distracted by sounds, consider headphones. Some people listen to brown noise instead of music to block out distractions. Consequences</p> <p>By focusing your attention on a single task at a time, you'll get more work done over a course of time, with better results on every task.</p> <h3>References</h3> • <a href=\"http://www.codinghorror.com/blog/2006/09/the-multi-tasking-myth.html\">The Multitasking Myth (CodingHorror.com)</a><br> • <a href=\"http://thetruthyoualwaysknew.com/2013/04/21/multitasking-is-impossible-focus-deeply-on-the-task-at-hand/\">Multitasking is impossible (TheTruthYouAlwaysKnew.com)</a><br> • <a href=\"http://www.forbes.com/sites/douglasmerrill/2012/08/17/why-multitasking-doesnt-work/\">Why multitasking doesn't work (Forbes.com)</a><br> <br>",
      "category": 1
    },
    {
      "title": "One change at a time",
      "url": "one-change-at-a-time",
      "summary": "A single commit should be <b>consistent</b> and contain only changes related to a single user story/issue. For instance, don't mix formatting changes with bug fixes.",
      "description": "<p>A single commit should contain only changes related to a single user story or issue. For instance, don't mix formatting changes with bug fixes. In other words: A change should have only one reason to be reverted.</p> <h3>Motivation</h3> <p>In case of problems it is very helpful to be able to blame just a few lines that were changed, instead of 20 files that contain everything from reformatting, refactoring log statements to changes in the transaction API.</p> <h3>Applicability</h3> <p>All projects where source control is used.</p> <h3>Application</h3> • Apply changes one at a time, e.g. when you fix two issue tracker tickets in the same file, record the changes for both fixes as separate commits in version control.<br> • Separate code clean up from functional changes. So Don't combine formatting changes and semantic changes in a single commit.<br> • Check each changeset before you push it to the central repository, to see if it communicates your intention.<br> <br> <h3>Effects</h3> • Easier to inspect and review changes in SCM history.<br> • Enables cherry-picking of changes.<br> • Reduces hassle if a change needs to be reverted<br> <br> <h3>References</h3> • <a href=\"http://essentials.xebia.com/small-increments\">Work in small increments</a><br> <br>",
      "category": 1,
      "bitly": "e00q9B"
    },
    {
      "title": "One feature at a time",
      "url": "one-feature-at-a-time",
      "summary": "First complete what you started before starting something new. It decreases time to market and allows you to apply experience gained during development of the first feature in the development of the next one.",
      "description": "<h3>Motivation</h3> <p>There is no point in trying to aim for everything, all in one go. If you are able to complete something early, you can move it into production and start feeding the ROI into the development of next features. If you are working on many things at the same time, you are basically denying yourself money.</p> <p>Other than that, doing many things at the same time comes with a cost. If a computer has to do many things at the same time, it will waste cycles switching between these different tasks. Your brain is not any different. Doing many tasks at the same time is like a juggling act. Juggling is way easier with just one ball. Juggling with just one ball is not only easier. It also increases that likeliness you will be able to complete your act without letting it drop on the floor.</p> <h3>Applicability</h3> <p>More often than not.</p> <h3>Application</h3> <p>Break the entire idea up into Minimal Marketable Features. You <em>could</em> consider calculating the net present value of each of these features, as \"Software by Numbers\" suggests. Alternatively, you take a slightly less scientific approach, and just sort the stories in the order you expect them to return most value early on. (However, bear mind that some features would earn you way more if you implement them <em>now</em>, rather than later on. The approach suggested by \"Software by Numbers\" factors this in.)</p> <p>Once you understand desired order for releasing the minimal marketable features, it's just a matter of feeding that to your teams in the appropriate order, and make sure the definition of done is clearly communicated. If we say \"one feature at a time\", we really mean \"one feature at a time\". In other words, that one features should really be completed, as much as possible. Getting it out there might require a bit more effort, but you will also enjoy the benefits of tapping into revenue streams early on.</p> <h3>Consequences</h3> <p>Question is how you deal with \"one feature at a time\" if you have many teams working on the same product. The solution is not to redefine minimal to \"whatever these teams can accomplish\". It will require you to carefully consider the dependencies between these Minimal Marketable Features and minimize them as much as possible. That includes making sure the architecture allows these Minimal Marketable Features to be developed independently as much as possible.</p> <p>At first glance, the easiest (but not necessarily most desirable) way to distribute work on Minimal Marketable Features between teams would be to have teams focusing on a particular layer or tier of your architecture. However, as a consequence, your teams will no longer be focused on completing the minimal marketable feature. They will instead have time left to work on other features as well. Chances are that - in the end, with all of the painful coordination between teams - you are left with a number of half-baked half-completed features, instead of a couple of features that are ready to be put out there.</p> <p>Instead of having teams that focus on particular architectural layers and tiers, it might be worth considering teams capable of completing the entire minimal marketable feature on their own. That makes an architecture that accommodates this a more attractive option.</p> <h4>References</h4> • Software by Numbers, Mark Denne and Jane Cleland-Huang, <a href=\"http://www.softwarebynumbers.org/\">http://www.softwarebynumbers.org/</a><br> • Service Integration at the Presentation Layer, Wilfred Springer, <a href=\"http://blog.xebia.com/2010/07/21/service-integration-at-the-presentation-layer/\">http://blog.xebia.com/2010/07/21/service-integration-at-the-presentation-layer/</a><br> <br>",
      "category": 2,
      "bitly": "hjPWim"
    },
    {
      "title": "Pair programming",
      "url": "pair-programming",
      "summary": "<b>Pairing</b> improves focus and fosters collective ownership more effectively than group discussions, documentation and reviews.",
      "description": "<h3>Motivation</h3> <p>Let's be honest. Over engineered solutions are strangely attractive. We developers are drawn into it like bugs into a bugzapper. We end up spending way too much time on things we don't even need. That's just wrong. We need somebody to get us back on track. And that's exactly what pair programming is going to give you.</p> <blockquote>  <p>When you pair, one person codes---the driver. The other person is the navigator, whose job is to think. As navigator, sometimes you think about what the driver is typing. (Don't rush to point out missing semicolons, though. That's annoying.) Sometimes you think about what tasks to work on next and sometimes you think about how your work best fits into the overall design. This arrangement leaves the driver free to work on the tactical challenges of creating rigorous, syntactically correct code without worrying about the big picture, and it gives the navigator the opportunity to consider strategic issues without being distracted by the details of coding. Together, the driver and navigator create higher-quality work more quickly than either could produce on their own.<a href=\"http://jamesshore.com/Agile-Book/pair_programming.html\">1</a></p> </blockquote> <h3>Applicability</h3> <p>Okay, there might be a few situations when you need some time alone. But, really, in all other cases, pair programming is applicable. That doesn't mean it's easy though. In fact, for most people, it turns out to be quite painful to say goodbye to their time spent in isolation, as evidenced by the type of response you will get when suggesting pair programming to die-hard alone coders:</p> • I'm faster on my own<br> • Can't pair with that colleague, I get nervous<br> • Pair programming is too tiring<br> • We've split up the work and we'll get it done faster if we use two keyboards<br> • There's too much background noise<br> • I'm just slowing her down<br> <br> <p>Iwein Fuld wrote a great article on the subject a in 2010, and this is what he said:</p> <blockquote>  <p>Some of this might sound plausible, so let me axe that down first. No you're not faster on your own, you're just creating more crap for your colleagues to puzzle over and eventually delete. The code you write alone sucks. That guy that is getting on your nerves is trying to tell you (clumsily) that your code sucks, try to listen to him and you'll turn into a better programmer. Or maybe you can teach him something and he'll stop getting on your nerves. If your code is so simple that you can split up the work in advance you're writing it on too low an abstraction level, or you need to work on this in two pairs. If you're slowing the other guy down, that's a good thing. That will prevent him from writing code that you cannot maintain. If you don't feel worthy of your colleagues code, get over it, or get off the team.<a href=\"http://blog.xebia.com/2010/05/09/practical-styles-of-pair-programming/\">2</a></p> </blockquote> <p>In some situations pair programming is not a good fit. Be sure to understand the need for <a href=\"http://essentials.xebia.com/alone-time\">alone time</a></p> <h3>Application</h3> <p>First of all, you optimize the conditions for pair programming. That could include many things, such as:</p> • Noise cancellation: if there's too much noise in your environment, if people are bothering you for the wrong things, if there are things that would prevent you from being focused even if you would be working on your own, then you need to fix it.<br> • Pair programming ergonomics: if you can't pair comfortably, then it's not going to fly. If your navigator is unable to read your screen, then it will fail. Getting another monitor might help. If - in order for the navigator to see the screen - the driver needs to work in a cramped position, it will fail as well. There are certain type of desks that just don't support pair programming at all. Rearrange the office floor to fix it. Make yourself comfortable.<br> • Pick a style. Iwein lists a number of styles in his article<sup>2</sup>^. Pick the right one for the task at hand.<br> <br> <h3>Consequences</h3> <p>Pair programming helps you to stay focused on your task and it grows collective ownership.</p> <h3>References</h3> • James Shore, The Art of Agile Development, 2010, <a href=\"http://jamesshore.com/Agile-Book/pair_programming.html\">http://jamesshore.com/Agile-Book/pair_programming.html</a><br> • Iwein Fuld, Practical Styles of Pair Programming, 2010, <a href=\"http://blog.xebia.com/2010/05/09/practical-styles-of-pair-programming/\">http://blog.xebia.com/2010/05/09/practical-styles-of-pair-programming/</a><br> <br>",
      "category": 2,
      "bitly": "dNoAYS"
    },
    {
      "title": "Prefer rich modes of communication",
      "url": "rich-communication",
      "summary": " • Personal conversation over telephone call<br /> • Telephone call over chat<br /> • Chat over email<br /> • Email over voice mail",
      "description": "<h3>Motivation</h3> <p>Poor or poorly understood communication is a common cause for failures, ineffective teams and interpersonal tension.</p> <h3>Applicability</h3> <p>Any job or environment where more than one person is involved. There even is strong evidence that a single person benefits from communicating with a fictitious partner (such as a rubber duck or a cardboard cutout of your favorite celebrity), a technique known as Rubber Ducking.</p> <h3>Application</h3> <p>Not all methods of communication are created equal. Choose the best available means of communication.</p> <h3>References</h3> • <a href=\"http://essentials.xebia.com/the-zone\">Respect the Zone</a><br> <br>",
      "category": 1,
      "bitly": "dKLvjK"
    },
    {
      "title": "Prevent your code base from turning into a museum",
      "url": "no-museum",
      "summary": "There is no point in keeping dead code lying around in your code base. Get rid of it.<br />Your version history will always allow you to get it back if you need to. The same goes for commented-out code: get rid of it.<br /><br />Keeping your codebase free of reminiscences of the past will make it easier to navigate and understand.",
      "description": "<h3>Also known as</h3> <p>HEAD is not a museum.</p> <h3>Motivation</h3> <p>The purpose of an SCM system is to store a history of your work, so there's no need to keep unused code or comments in your current build.</p> <h3>Applicability</h3> <p>Whenever you see commented-out or unused code and/or outdated comments in source code or documentation.</p> <h3>Application</h3> <p>Remove unused variables, methods etc., any code commented-out without an accompanying explanation (e.g. a temporary workaround for a blocking issue), any tests ignored without explanation and any outdated comments or documentation from your source code and update your SCM system. Also, remind your colleagues that these items should be removed.</p> <h3>Consequences</h3> <p>The HEAD of your project will reflect the current state of your code, not an arbitrary mix or current code any stuff hanging around because nobody is 100% sure whether it is in use or not.</p>",
      "category": 1,
      "bitly": "ifpmb5"
    },
    {
      "title": "Remember the fallacies of distributed computing",
      "url": "fallacies-distributed-computing",
      "summary": "<blockquote> • The network is reliable<br /> • Latency is zero<br /> • Bandwidth is infinite<br /> • The network is secure<br /> • Topology doesn't change<br /> • There is one administrator<br /> • Transport cost is zero<br /> • The network is homogeneous<br /></blockquote><em>Peter Deutsch</em>",
      "description": "<h3>Motivation</h3> <p>Peter Deutsch asserted that programmers new to distributed applications invariably make a set of assumptions known as the Fallacies of Distributed Computing and that all of these assumptions ultimately prove false, resulting either in the failure of the system, a substantial reduction in system scope, or in large unplanned expenses required to redesign the system to meet its original goals.</p> <h3>Applicability</h3> <p>More often than not, we at Xebia work on distributed systems. In our industry, it is not uncommon to ignore the fallacies of distributed computing.</p> • The network is reliable.<br> • Latency is zero.<br> • Bandwidth is infinite.<br> • The network is secure.<br> • Topology doesn't change.<br> • There is one administrator.<br> • Transport cost is zero.<br> • The network is homogeneous.<br> <br> <p>Ignoring these properties will lead to brittle systems. We don't want to create brittle systems; we want to create robust systems. Systems that survive network failure. Systems that do not need the constant presence of a network administrator in order to survive. Systems that are resilient to changes to the network topology.</p> <h3>Application</h3> <p>First of all, you need to be aware of the existence of this list and understand that there is no such thing as a free ride. When the network is getting involved, you need to be be aware of the consequences, and design for it.</p> <p>In addition to that: Many attempts have been made to hide the complexity of coping with the characteristics of a distributed system. Be careful with those solutions. Solutions that suggest that you should not worry about the network and allow you to create software as though the network wasn't there are suspicious.</p> <h3>Consequences</h3> <p>It is one thing to be aware of the consequences of your decisions when designing for a distributed solution. By carefully choosing from your options, you can most definitely increase the resilience of your system against network failures. However, increasing the robustness of your system might also increase the complexity of the programming model.</p> <p><a href=\"http://en.wikipedia.org/wiki/Jini\">Jini</a> is an example of a technology that definitely took the 8 fallacies of distributed computing seriously, and I think it's fair to say it was much more resilient to networking issues than Java EE solutions coming about around that same time frame. However, it did put a burden to the developer. You had to write more code in order to be able to deal with whatever could go wrong.</p> <p>Now, question is if your solutions always need to have the same properties as Jini-based solutions, especially if there is a price you will have to pay for it. Probably not. In the end, it's just a balancing act, balancing factors such as the price business is willing to pay for ultimate availability, the characteristics of the data center(s) and the experience of the team you are working with.</p> <h3>References</h3> • <a href=\"http://en.wikipedia.org/wiki/Fallacies_of_Distributed_Computing\">Wikipedia</a><br> <br>",
      "category": 3,
      "bitly": "eEc5jq"
    },
    {
      "title": "Respect the zone",
      "url": "the-zone",
      "summary": "<b>'The zone'</b> is a mode of consciousness that is associated with higher capabilities. When in the zone a developer is more productive.<br /><br />When a developer is in the zone, avoid disruptions.",
      "description": "<h3>Also know as</h3> <p>Flow, as in in the Flow</p> <h3>Motivation</h3> <p>Have you ever experienced a feeling that time stood still, or perhaps that time passed without you noticing? This could have been when you were reading a book, playing as a child, while sporting, but it could also happen when you are working. This state of mind, which resembles the state of mind of people in trance or under hypnosis has been described abundantly in literature and has been the subject of scientific research. Apart from the fact that it is healthy and enjoyable to be in such a state of mind, it has also been associated with higher productivity.</p> <h3>Applicability</h3> <p>When we talk about hyperproductivity or enhancing the productivity of creative people in general we also should consider how to keep them in the zone as much as possible.</p> <h3>Application</h3> <p>One of the most common things to do is to avoid interruptions, but also adding appropriate visual elements in a room (art instead of clutter, plants instead of machines) can help reach a state of flow. Physical exercise, drinking enough water, a healthy diet are helpful to make the mind more likely to enter and stay in the zone. Interaction with other people immersed in the same problem space can help avoid interruptions and draw a whole team into the zone. To increase this type of interaction you should ensure there is lots of physical communication equipment. Whiteboards, large papers (flip chart), markers, pencils, crayons. It sometimes helps to add toys to draw developers out of their hiding places inside their screen and interact with each other The most important thing is to let developers be in a bubble that is not often pierced by things that are not part of their zone.</p> <h3>Consequences</h3> <p>Team moral will go up when an atmosphere is created where zoning in is allowed and encouraged. Productivity will go up. When team zoning happens problems are much less often discarded as unsolvable. Symptoms that can be seen on the outside are:</p> • constant soft chatter between developers<br> • people moving around from desk to desk<br> • more joking and laughter<br> • increased use of non digital tooling (whiteboards, paper, gesturing, role play)<br> <br> <h3>References</h3> • <a href=\"http://essentials.xebia.com/pair-programming\">Pair Programming</a><br> • <a href=\"http://scholar.google.com/scholar?hl=en&amp;q=Cs%C3%ADkszentmih%C3%A1lyi+flow&amp;btnG=Search&amp;as_sdt=2000&amp;as_ylo=&amp;as_vis=0\">Google Scholar: Csíkszentmihályi flow</a><br> <br>",
      "category": 2,
      "bitly": "fkrkGA"
    },
    {
      "title": "Review code",
      "url": "code-review",
      "summary": "The primary goal of code review is to increase its quality.<br /> It can be used as an additional safety net alongside pair programming.<br /><br />It is also a good way to share knowledge and pick up some new tricks.",
      "description": "<h3>Motivation</h3> <p>We care about quality. Since everyone makes mistakes we reduce the risk of mistakes escaping to production by reviewing all code. Together with <a href=\"http://essentials.xebia.com/pair-programming\">Pair Programming</a> this practice ensures that always two pairs of eyes have seen all production code.</p> <h3>Applicability</h3> <p>Reviewing code is a great way to get an overview of a code base; to learn the style and the domain. It is also a way to view the code from an unusual standpoint and see inconsistencies that would otherwise stay out of focus. The only way to truly know the internal quality of a code base is to read the code. Apply reviews when you're not sure about the code quality, or when you want to coach a team to better quality code through concrete feedback.</p> <h3>Application</h3> <p>Reviewing can be done in several ways. First there is the old fashioned way: just take a text editor (with highlighting if you can) and read the code file by file. It can be useful to load the code in an IDE, but since you're not here to check if it will compile this might just as well be an unneeded distraction. While reading the code write down concretely what you would change if you were refactoring. Share this with the developers through a simple text.</p> <p>Then there is the per commit reviewing style, that allows the reviewer to review changes rather than the end result. This is perfect for quick feedback on developer behaviour, rather than the result of the behaviour. It takes more time and discipline to review all commits.</p> <p>A great way of code reviewing is by using Pull Requests. Pull requests are a feature of most DVCS hosting tools. If your project is on a distributed version control system (DVCS) like Git or Mercurial, you can use such a system. It's basically a pending merge from one branch into another, accompanied by a commenting system. The great thing about pull requests is that they're asynchronous (you don't have to interrupt a colleague in their work), persistent (the reviewing comments are archived), up-to-date (the scope of the code review automatically updates as further commits are made on the development branch) and public (pull requests are visible to the entire team, anyone can chip in). At GitHub, it's not uncommon for a pull request to live for months before being merged. There's a great talk about how they use them: <a href=\"http://zachholman.com/talk/how-github-uses-github-to-build-github/\">How GitHub uses GitHub to build GitHub</a>.</p> <p>Note that Code Reviewing and <a href=\"http://essentials.xebia.com/pair-programming\">Pair Programming</a> are not interchangeable, because they serve different goals.</p> <h3>Consequences</h3> <p>It's easier to feel shared code ownership when reviewing is done by team members. When reviews are done it is important to invest time in dealing with the findings. Otherwise the (sometimes mundane) task of reviewing is not rewarded properly and will feel like a waste of time.</p> <h3>Samples</h3> <p>There are tools that help reviewing greatly, such as Crucible (commercial) and of free tools around the git vcs, like Gerrit and the GitHub review system. Especially when reviewing per commit, decent tooling is a must have.</p>",
      "category": 2,
      "bitly": "gOpcIU"
    },
    {
      "title": "Run tests automatically",
      "url": "run-tests-automatically",
      "summary": "Starting tests by hand is needless friction. Don't just use a build server. Use an IDE plugin that tracks source/test dependency and runs the affected tests whenever you save a file.",
      "description": "<h3>Motivation</h3> <p>Modern computers are extremely fast. Utilise a little of that power to provide you with very fast feedback as you're doing your work. You don't even have to hit a <a href=\"http://essentials.xebia.com/master-your-tools\">keyboard shortcut</a> anymore.</p> <h3>Applicability</h3> <p>This is a useful tool if you're somewhat accustomed to test-driven development.</p> <h3>Application</h3> <p>This is a very simple addition to your day to day work as a software developer. When performed in a TDD cycle, you know exactly when you've written enough code, because then the test will turn green.</p> <h3>Consequences</h3> <p>As a side effect of running your tests this often, you might become aware of the actual time your tests take to run. Are all tests as still as valuable as when you wrote them?</p> <h3>Samples</h3> <p>Infinitest for Eclipse and IntelliJ.</p> <h3>References</h3> • <a href=\"http://essentials.xebia.com/independent-tests\">Independent Tests</a><br> • <a href=\"http://essentials.xebia.com/tdd-shapes-design\">TDD Shapes Design</a><br> • <a href=\"http://essentials.xebia.com/automate-everything\">Automate Everything</a><br> <br>",
      "category": 4
    },
    {
      "title": "Separation of concerns",
      "url": "separation-of-concerns",
      "summary": "<blockquote>Separate a program into non-overlapping concerns.</blockquote><em>Edsger W. Dijkstra</em>",
      "description": "<p>Separate a program into non-overlapping concerns. Edsger W. Dijkstra</p> <h3>Motivation</h3> <p>Clearly separated code has some advantages.</p> <p>Firstly, the programming units are small and are less dependent on each other. This eases testing.</p> <p>Secondly, when concerns are cleanly separated it's easier to reason about the application. This is a valuable asset during development as well as exploitation of the application.</p> <h1>See also</h1> • <a href=\"http://essentials.xebia.com/tdd-shapes-design\">TDD Shapes Design</a><br> • <a href=\"http://essentials.xebia.com/maximize-cohesion-minimize-coupling\">Maximize Cohesion, Minimize Coupling</a><br> • A <a href=\"http://en.wikipedia.org/wiki/List_of_pioneers_in_computer_science\">List of Pioneers in Computer Science</a> on Wikipedia.<br> <br>",
      "category": 3,
      "bitly": "ehkmTM"
    },
    {
      "title": "Share the design",
      "url": "shared-design-understanding",
      "summary": "Everyone in the team should be aware of the <b>core design ideas</b> that have given shape and structure to the software so far, and understand the underlying intent.",
      "description": "<h3>Motivation</h3> <p>Having no shared understanding of what you are jointly aiming for is a recipe for disaster:</p> • Conceptual integrity will be broken.<br> • The discussion will slide to your code base.<br> • Which will eventually turn your code base into a battle ground.<br> • It's not uncommon people will undo the changes of others, thinking it is not the right way - mind you, without a joined agreement on what constitutes 'the right way'.<br> <br> <h3>Applicability</h3> <p>It applies on all levels of the IT organization, but most certainly to development teams.</p> <h3>Application</h3> <p>There are a couple of things you can do to increase a shared understanding of the design objectives.</p> • Pair programming helps: even though it synchronizes between two people only, if you switch pairs frequently, and if you prevent your team members from getting too attached to a particular area of the code base, you will eventually get a shared design understanding.<br> • Joint design discussion: as soon as you notice blank stares when discussing a particular area of the code base, you should step up and demand allocating some time to discuss that part of the codebase.<br> • Plaster the walls: any material coming out of the design discussions should be on the wall. And it should be updated if it no longer reflects the current understanding.<br> <br> <h3>Consequences</h3> <p>A shared understanding of the design will help people understand the consequences of their actions. Not having a shared understanding of the design will quickly cause people to claim a certain portion of the code base they understand, which eventually will result in a fragmented code base without any conceptual integrity at all.</p> <p>Having design meetings of course is expensive. Having some preparation might help, but pictures drawn during the meeting normally have a longer lasting effect. And you should keep in mind that ideas captured during preparation might turn out to be invalid during the discussion.</p> <p>The advice is not to have design discussions during the stand-up, but perhaps right after it. Somebody should take the responsibility to make sure the results are captured on the wall.</p>",
      "category": 3,
      "bitly": "hV9Kxv"
    },
    {
      "title": "Sleep easy on a green build",
      "url": "no-broken-builds",
      "summary": "It's the team's code; it's also the team's <b>responsibility</b> to have a running build. If the person who broke the build isn't around, that's no excuse.",
      "description": "<h3>Also known as</h3> <p>Nobody goes home until the build is fixed</p> <h3>Motivation</h3> <p>Your build state is your code's heartbeat. A broken build means you're not delivering value, and you certainly don't have production-ready software.</p> <h3>Applicability</h3> <p>If you're using a continuous build system (you are, aren't you?), you should have trouble sleeping if the build isn't green.</p> <h3>Application</h3> <p>Ensure you receive automatic alerts when your build breaks and also when it is fixed. If a build is broken it is the responsibility of the entire team to ensure the build is fixed. Of course, the person responsible for the check-in that broke the build is the most natural person to delegate this task to, but if that person is on holiday that's not an excuse to ignore the problem!</p> <h3>Consequences</h3> <p>If you have a broken build (and certainly if you were responsible for it breaking!) you should feel bad if you're working on anything other than fixing it. If your team starts ignoring build failure notifications - or even starts setting up mail filters for them! - consider if the build setup is still relevant to your project's needs. For instance, there's no point in having a quality build that fails continuously because it is verifying style rules the team is no longer using.</p> <p>If your failing build(s) are still relevant to your project and the team is ignoring them anyway, raise the alarm.</p> <h3>References</h3> <p>There are also a number of \"build league tables\" and other plugins for many continuous build tools that can make keeping the build green a bit more fun and exciting.</p>",
      "category": 2,
      "bitly": "ejXw87"
    },
    {
      "title": "Split functionality into small units",
      "url": "thirty-minute-methods",
      "summary": "A function should be replaceable by one of your colleagues in less than <b>thirty minutes</b>.",
      "description": "<h3>Motivation</h3> <p>When you're in the thick of it it is hard to see where you should split up a bit of work. Usually a couple of lines is perfect, but if you're doing something mundane like a switch statement the mental overhead might be higher if you split things up.</p> <p>One rule that is easy to apply and remember is that someone in your team needs to be comfortable to replace the method within a short span of time. 30 minutes is a number to stay below.</p> <h3>Applicability</h3> <p>Apply this when code is written.</p> <h3>Application</h3> <p>Question yourself before you leave a context if the methods/functions are not too complex or too scattered.</p> <h3>Consequences</h3> <p>You should see more consistent method sizes and more readable code after you've applied this as a team for a while.</p>",
      "category": 3,
      "bitly": "fIHSOX"
    },
    {
      "title": "Start with acceptance criteria",
      "url": "acceptance-criteria",
      "summary": "<b>Acceptane criteria</b> should be part of your Definition of READY. Make sure everyone has a common understanding of what they are before building anything.<br />Safeguard your acceptance criteria in automated tests.",
      "description": "<h3>Also known as</h3> <p>Don't start without acceptance criteria.</p> <h3>Motivation</h3> <p>Make sure everyone has common understanding before building anything. Acceptance criteria should be part of your Definition of Ready. You're not done when acceptance criteria aren't automated.</p> <p>All software built should be made for a reason. It's valuable to capture that reason. Normal (Word) documents are not enough to work from. They leave room for ambiguity.</p> <h3>Applicability</h3> <p>It's best to think about acceptance criteria for a feature/story, before the implementation starts. Preferably before the sprint starts, so the team has as much information about the feature as possible.</p> <h3>Application</h3> <p>When defining your acceptance criteria, think about the “What”: What should it do? Not: how should it be done. The How is about implementing the feature. We're searching for What it should do in terms of business functionality.</p> <p>Before you start to work on a feature or user story it's good to know what the expectation of the business or product owner is about that particular feature. Make this as formal as possible. Preferably to the extend that it can be automated in a breeze.</p> <p>Think about examples of how a particular feature can be used. How are you going to demo it once it's built?</p> <h3>Consequences</h3> <p>As a consequence business and development team will have a much better understanding about what the application will do. Developers on the other hand have a better understanding about what the business is trying to achieve with a particular feature and can help the business find better ways to achieve their goal.</p> <h3>Samples</h3> <p>Specification by Example is one way to deal with acceptance criteria in terms of (usage) examples.</p> <h3>References</h3> • <a href=\"http://essentials.xebia.com/tests-are-specs\">tests-are-specs</a><br> • <a href=\"http://essentials.xebia.com/brutal-transparency\">brutal-transparency</a><br> <br>",
      "category": 4
    },
    {
      "title": "Take time to tackle tech debt",
      "url": "time-for-tech-debt",
      "summary": "Make your Product Owner <b>understand</b> why it is critical to fix technical debt. Explain that sustainable pace is the only way.",
      "description": "<h3>Motivation</h3> <p>If you can't make time to tackle tech debt it will just keep on growing, and once the ball of mud is big enough, nobody can move anymore.</p> <h3>Applicability</h3> <p>Most teams have quite a good idea of how much tech debt they are accumulating in their code. But since it can be hard to convince some Product Owners of the need to work on such \"purely technical\" issues that do not deliver any features, and there is always one more workaround one can apply, it often accumulates.</p> <p>At a certain point, there is so much tech debt that tackling it would consume a significant percentage of development resources, at which point it becomes even harder to persuade the PO to invest that much time.</p> <h3>Application</h3> <p>Be prepared for the fact that some Product Owners, especially those with little technical experience, or those under a lot of pressure from stakeholders to deliver features, find it hard to understand the need for work that doesn't appear to \"deliver\" anything. Try to explain why keeping tech debt within manageable levels is a task that should have a reasonably high priority.</p> <p>If you are already facing a backlog of tech debt - and most projects will, because it is also not economical to do everything perfectly - don't hide that fact during estimation. Resist basing your estimates on ugly hacks or workarounds - if implementing a certain feature means that a certain item of tech debt needs to be tackled, include the tech debt work in the estimate.</p> <p>Otherwise, a Product Owner will never see the strangling influence of tech debt on the team's ability to deliver features.</p> <h3>Consequences</h3> <p>With luck, you should arrive at a situation where tech debt is monitored and kept within levels that are deemed manageable within the context of your project - levels that have been agreed by the team and the PO.</p> <h3>References</h3> • <a href=\"http://essentials.xebia.com/dare-to-say-no\">Dare To Say No</a><br> <br>",
      "category": 1,
      "bitly": "fWNq5P"
    },
    {
      "title": "Test Driven Development shapes design",
      "url": "tdd-shapes-design",
      "summary": "Well-structured code follows naturally from the <b>test-driven development</b> (TDD) process.<br /><br />However, locally emergent architecture without an overall vision can become incoherent in the large.",
      "description": "<h3>Also known as</h3> <p>Red-Green-Refactor.</p> <h3>Motivation</h3> <p>There are many ways to start a software project. Why not start with requirements. No, we're not back in the 80's!</p> <p>Start with a basic requirement, craft it into a test and let those tests drive development.</p> <h3>Applicability</h3> <p>This is extremely useful when it comes to writing applications. By performing the red-green-refactor cycle you:</p> • Write down a feature in test code. Do not be concerned about compiler errors. It's the thought process that counts. What is it I want to achieve.<br> • Implement the actual (production) code. Only to the extend that the test passes. While writing code you might come up more cases to test. Write those down (e.g. on a piece of paper), we're focused on making the test at hand pass.<br> • Tidy up. Make sure your code is ready for the next cycle. Is the code self-descriptive?<br> <br> <h3>Application</h3> <p>Whenever you're writing an application this approach is applicable.</p> <p>There are a few corner cases where this approach is less applicable: when you're learning yourself a new library, for example. In those cases you have no idea how the library behaves and you're basically just testing the library.</p> <h3>Consequences</h3> <p>You'll find out that you have to write less tests and code in general. Since all you're implementing are the features that you describe in your test cases, the code is as good as the test cases. Therefore it's important to have clear, readable tests. Nothing is more confusing than a test whose intention is unclear.</p> <h3>References</h3> <p><a href=\"http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627/\">Freeman, Price: Growing Object-Oriented Software, Guided by Tests</a></p>",
      "category": 4
    },
    {
      "title": "Testing is a shared responsibility",
      "url": "testing-is-shared-responsibility",
      "summary": "Testing is not just the domain of the tester, but a core value for the development team. Every developer is a tester first.",
      "description": "<p>Testing is not just the domain of the tester, but a core value for the development team. Every developer is a tester first.</p>",
      "category": 4
    },
    {
      "title": "Tests are Specifications",
      "url": "tests-are-specs",
      "summary": "Don't test an <b>implementation</b>, test its <b>conformance</b> to a required behaviour. Tests written in this way become executable specifications, stories and examples.<br />They document what the code is intended to do, not cast in cement how it does so.",
      "description": "<h3>Motivation</h3> <p>A good test describes a certain aspect of your system on a functional level. In this sense, a test is not much different from a specification. While traditionally specifications have been written up-front and tests afterwards, this trend has changed.</p> <p>A <a href=\"http://essentials.xebia.com/acceptance-criteria\">specification written at the beginning of a project</a> needs to be continuously maintained to stay relevant in rapidly-changing environments - and today, all environments change rapidly. As such, the specification has become a living part of the product, just like production code and tests.</p> <p>Conversely, with software being developed and deployed iteratively, tests are written earlier in the process, sometimes <a href=\"http://essentials.xebia.com/definition-of-ready\">before the actual features are implemented</a>. This is a good thing.</p> <p>Due to these trends the distinction between functional tests and specifications is quickly disappearing: it often helps to think of tests as specifications and specifications as tests.</p> <h3>Applicability</h3> <p>Tests that don't look like specifications are not very good tests: often they test how a feature is implemented, not that.</p> <p>Specifications that don't look like tests are not very good specifications: often they are too vague, sometimes giving a <a href=\"http://essentials.xebia.com/shared-design-understanding\">false sense of consensus</a> on the feature.</p> <h3>Consequences</h3> <p>Your process probably no longer has separate 'waterfall' phases for specification (up-front) and testing (afterwards). However, in many organizations, specification and testing are still the responsibilities of disparate roles or even teams. When you consider tests are specifications, the consequence is that specification and testing should be the <a href=\"http://essentials.xebia.com/testing-is-shared-responsibility\">joint responsibility of a multidisciplinary team</a> consisting of both people with a background in specification/requirements engineering and people with a background in testing/test automation.</p> <h3>References</h3> <p>http://www.specificationbyexample.com</p>",
      "category": 4
    },
    {
      "title": "Tests should be fast, reliable and independent",
      "url": "independent-tests",
      "summary": "<b>Independent unit tests</b> can be run regardless of ordering and are easy to run in parallel. Speed and reliability optimize feedback.<br /><br /> • Don't share objects between tests.<br /> • Minimize external dependencies, use mocks.<br /> • Give each test the smallest possible scope.<br /> • Optimize slow tests to make them not slow.<br /> • Optimize flaky tests to make them reliable.",
      "description": "<h3>Also known as</h3> <p>Listen to your tests.</p> <h3>Motivation</h3> <p>Make sure tests run independent and do not rely on external factors in order to succeed. In doing so, tests can be executed in isolation (for example with a debugger) as well as in sets. You're also relying less on the execution engine, which can be considered a good thing.</p> <p>By isolating tests it's easier to track down issues.</p> <p>In the end, it's all about feedback.</p> <h3>Applicability</h3> <p>This approach is applicable throughout the application delivery process.</p> <h1>Don't share objects between tests.</h1> <p>Sharing objects (or more commonly state) between tests makes it hard to find an issue in a test. You're always relying on some other \"thing\" to prepare the test state for your test. Note that state can be object state as well as state in external systems (see also next point).</p> <p>Minimize external dependencies, use mocks.</p> <p>Mocks give you the ability to tailor the behaviour of the \"external\" dependencies.</p> <h1>Give each test the smallest possible scope.</h1> <p>Make one test per feature. Even if the second test is building on the first test, make a new test.</p> <p>Keep your tests functional (what is the observable behaviour?).</p> <h1>Optimize slow tests to make them not slow.</h1> <p>Listen to your tests.</p> <p>Why is your test slow? It's worth investigating.</p> <h1>Optimize flaky tests to make them reliable.</h1> <p>Why is a test flaky? Are there multiple concerns to the object under test? Are you mixing application layers?</p> <h3>Application</h3> <p>Start with this when writing your code. Start with a test, TDD style: describe what an entity should do. Implement it and describe the next feature. Keep a piece of paper next to you to write down notes while implementing. In doing so, you drive the code through tests. Tests are the most concrete way to describe a piece of functionality: since they're written in a programming language, they can only be interpreted in one way. No ambiguity.</p> <h3>Consequences</h3> <p>You wouldn't believe what proper tests can do to code.</p> <h3>References</h3> • <a href=\"http://essentials.xebia.com/tdd-shapes-design\">TDD Shapes Design</a><br> <br>",
      "category": 4
    },
    {
      "title": "Think of code and test as one",
      "url": "test-code-one",
      "summary": "<blockquote>When writing the code, think of the test.<br /><br />When writing the test, think of the code.<br /><br />When you think of code and test as one, testing is easy and code is beautiful.</blockquote><em>Testivus</em>",
      "description": "<h3>Motivation</h3> <p>The card actually says it all. Writing the code while keeping in mind how you're going to test it will change the way you write your code. There is a fair chance you want to test your module in isolation. That imposes some restrictions on the design of your module: it forces you to minimize coupling as much as possible. And as it turns out, that's a desirable property of software any way.</p> <p>The reverse effect obviously also occurs when you are writing the test. You don't just write random test code. You carefully consider the different states in which your module might end up being in, and you adjust your way of testing around that.</p> <h3>Applicability</h3> <p>Always. This is one of the reasons why having accepting test criteria associated with your user stories is important.</p> <h3>Application</h3> <p>There are two ways of writing your code. You either start with your code, or you start with your test. Test driven development is about starting with your test, and never start writing code before you have a test that is failing. That way, your code basically flows from your tests. Consequently, your code is influence by the tests only, and not the other way around.</p> <p>My personal suggestion would be to go back and forth between your code and your tests.</p> <h3>Consequences</h3> <p>Circling around between test and code might make it harder to define a stop criterion. And 80% test coverage rule might help. Getting up to 100% test coverage will be hard or (in many cases) impossible. Using assertions inside your code will definitely help to make up for the remaining 20%. Testing your code forces you to take some design decision consciously; adding assertions will have the same effect.</p> <h3>References</h3> <p>The Way of Testivus - Unit Testing Wisdom From An Ancient Software Start-up, Albert Savoia, <a href=\"http://www.agitar.com/downloads/TheWayOfTestivus.pdf\">http://www.agitar.com/downloads/TheWayOfTestivus.pdf</a>, 2007</p>",
      "category": 4,
      "bitly": "hw4BK8"
    },
    {
      "title": "Three strikes and you automate",
      "url": "three-strikes",
      "summary": " • The first time you do something, you just do it manually<br /> • The second time you do something similar, you wince at the repetition, but you do it anyway<br /> • The third time you do something similar, you automate<br />",
      "description": "• The first time you do something, just do it by hand.<br> • The second time you do something similar, wince at the repetition and do it anyway.<br> • The third time you do something similar, you automate.<br> <br> <h3>Motivation</h3> <p>We're not in the software business to perform repetitive work. If we can automate business processes we can just as well automate the dull work in our daily job.</p> <h3>See also</h3> • <a href=\"http://essentials.xebia.com/run-tests-automatically\">Run Tests Automatically</a><br> <br>",
      "category": 1,
      "bitly": "gKF9po"
    },
    {
      "title": "Timebox the unknown",
      "url": "timebox",
      "summary": " • Timebox a story/task that can't be estimated during planning.<br /> • Communicate the results to the product owner / scrum master in order to have accurate estimates.<br /> • You must stay within the boundaries of a timebox.",
      "description": "<h3>Also known as</h3> <p>Spike</p> <h3>Motivation</h3> <p>When you cannot estimate the time it would take to finish a job because you have no clue of the complexity of the problem, or the solution is dependant upon various intermediary results, then it pays to put a time limit on the amount of effort being invested in solving the problem.</p> <h3>Applicability</h3> <p>When you cannot reasonably estimate the time it would take to finish a job.</p> <h3>Application</h3> <p>Identify the first step towards the solution to the problem. Put a fixed amount of time to be invested for the first step. At the end of that time frame, revisit the problem with the experience you have gained and decide the next step.</p> <p>The fixed amount of time should not be too large. Try not to have it longer than two weeks.</p> <h3>Consequences</h3> <p>This kind of approach helps you to get started with tasks whose solutions are not known upfront. It prevents us from shooting in the dark for large periods of time. It is one of the approaches to fail-fast.</p>",
      "category": 2,
      "bitly": "ePLE2z"
    },
    {
      "title": "When you don't have time to test everything, you're building too much",
      "url": "test-everything",
      "summary": "When a story isn't tested, it simply is <b>not ready for production</b>. This means that focus should be on testing throughout the sprint, by the whole team. No new work should be picked up if there is still unfinished test work.",
      "description": "<h3>Motivation</h3> <p>The definition of done for a user story contains the acceptance criteria. Testing these acceptance criteria assures actual business value is delivered and guarantees that a user story is actually done. This makes testing an essential part of any functionality delivered. Any functionality which is created without being tested is waste as its business value has not been determined.</p> <h3>Applicability</h3> <p>Whenever software is developed the focus must lie on creating fully tested functionality, if the goal is to deliver business value.</p> <h3>Application</h3> <p>The simplest way to track if tests are executed, is by creating a test-task for every user story. Testing should be done by, or in cooperation with, people who focus on functionality. They can either be functional testers or domain experts, such as the product owners or business analysts.</p> <p>To ensure that testing doesn't become a bottleneck in your process, testing should have focus throughout the sprint.</p> <p>In order to prevent testing results in a mini-waterfall (with testing right at the end of every sprint), testing must be done in advance, as part of the definition of ready for a user story. When modeling the acceptance criteria in executable specifications, these can be referenced by the developers and used for Acceptance Test Driven Development. The modeling of the test automation should be done in collaboration between testers and developers. This collaboration results in shared understanding of the functionality and it ensures user stories get extra attention on testability and completeness, before development starts. During the development phase the initial tests (that have been created upfront) can be extended with variations and corner cases. This approach results in the shortest possible feedback cycle and as an additional advantage it boosts communication between team members and stakeholders, but most important it results in fully tested user stories, within the sprint.</p>",
      "category": 4,
      "bitly": "gu1Lq3"
    },
    {
      "title": "Work in small increments",
      "url": "small-increments",
      "summary": "Every commit should be a change from one stable state of the system to another stable state of the system, and should not represent more than <b>two hours</b> of work.",
      "description": "<h3>Motivation</h3> <p>The natural tendency of developers is to fix the world as they move through it. This is a good habit, but each small fix there should isolated. Stop the world refactorings are doomed to fail, so you should strive to avoid them.</p> <h3>Applicability</h3> <p>In any situation where you are changing a working system. Usually we apply this to software, but it works equally well in teams, cars and households.</p> <h3>Application</h3> <p>Learn to limit the amount of work you do between commits. This forces you to break your work into small, coherent changes, often a number of changes that preserve existing functionality while paving the way for the new features, followed by one more more changes that enable the new behaviour.</p> <p>Run your test suite before every commit.</p> <h3>Consequences</h3> <p>Easier integration: fewer merge conflicts occur and when they do they're much easier to resolve. Higher quality: you can't break your work into small, coherent changes without a clear understanding of your goal and how to get there. The small, coherent changes are easier to keep in your head at once. These factors combined tend to improve the quality of your code and reduce the number of defects. All changes are optional. If you decide to keep the new feature, but not to deprecate the old API you can revert the deprecation in isolation. This is also useful to limit impact if you need to cut your losses and back out of a bad idea. Reordering of changes becomes possible. When changes depend on each other this becomes a non trivial exercise, but it is usually possible to change the order of changes in retrospect.</p> <h3>References</h3> • <a href=\"http://essentials.xebia.com/one-change-at-a-time\">one-change-at-a-time</a><br> • <a href=\"http://essentials.xebia.com/thirty-minute-methods\">thirty-minute-methods</a><br> <br>",
      "category": 1,
      "bitly": "g5LPEg"
    },
    {
      "title": "Work on stories when they're ready",
      "url": "definition-of-ready",
      "summary": "Have a Definition of <b>READY</b> to judge whether a user story is fit to go into a sprint.<br /><br /> • Do the team members understand the story?<br /> • Is the story sized correctly?<br /> • Have the acceptance criteria been defined?<br /> • Are the external dependencies in place?<br /> • How will the demo look?",
      "description": "<h3>Motivation</h3> <p>Definition of Ready aims to define an acceptance criteria that a User Story must pass in order to become eligible to be considered for inclusion in Ready sprint backlog.</p> <h3>Applicability</h3> <p>Definition of Ready is an important tool that can be used by a scrum team to judge whether a user story is ready to be taken up for discussion in a sprint planning.</p> <h3>Application</h3> <p>While planning a sprint, a User Story must pass the following criteria in order to become eligible for inclusion in a sprint.</p> • A User Story must define an acceptance criteria which is testable.<br> • A User Story must also share information on why is it required, giving the team a bigger context on the importance of the story.<br> • Team should be able to estimate it; In other words there should be a loose implementation strategy associated with it.<br> <br> <h3>Consequences</h3> <p>By including a story in the sprint that is not READY, the team risks building something that is not fully defined; This may lead to re-work. Another consequence could be expanding/shrinking scope of the problem of the story while the sprint is in progress.</p> <h3>References</h3> • Serge's Blog: <a href=\"http://blog.xebia.com/2009/06/19/the-definition-of-ready/\">http://blog.xebia.com/2009/06/19/the-definition-of-ready/</a><br> • <a href=\"http://www.nomad8.com/files/0787c369f92e9581d8ccf145ec62181b-15.php\">Another Interesting Blog From a Scrum Coach on DOR</a><br> <br>",
      "category": 2
    },
    {
      "title": "Write code that humans can easily understand",
      "url": "readable-code",
      "summary": "<blockquote>Any fool can write code that a computer can understand. Good programmers write code that humans can understand.<br />A simple, readable implementation is head and shoulders above a clever-but-confusing, look-at-me implementation.<br />Things to keep in mind are readability, maintainability and speed of development.</blockquote><em>Martin Fowler</em>",
      "description": "<h3>Also known as</h3> <p>Beautiful code is simple code that humans can understand easily.</p> <h3>Motivation</h3> <p>We want to keep our systems maintainable over time, with clean, simple, testable code, keeping the speed of development high throughout the lifetime of the system.</p> <p>You'll only get good code if you actually care about good code.</p> <h3>Applicability</h3> <p>Any time you touch a piece of code you strive to leave it better than you found it (either better structured, better tested, more understandable...).</p> <h3>Application</h3> <p>Find some open source code written by some well known acknowledged experts and see how the code is written. Compare it with the way you write code.</p> <p>Start reading some of your oldest code and work. Reading your own old code can also be an enlightening experience. You will probably find that it is not at all as easy to read as when you wrote it. Look at how you have developed your skills over the years — it can be truly motivating. Observe what areas of the code are hard to read, and consider whether you are still writing code in the same way today.</p> <p>For the person trying to understand your code, well written test cases are of great help. Hence pay great attention to the readability of the test that you write for your code. Test cases should report errors in helpful and meaningful way.</p> <p>Write code as if you had to support it for the rest of your life. If you keep this point in mind, you would gradually improve towards becoming an expert programmer.</p> <h3>Consequences</h3> <p>Writing a simple readable code forces you to think straight in terms of overall design and the flow of the code.</p> <p>People will form opinions about you based on the code that they see. If those opinions are constantly negative, you will get less from your career than you hoped. Take care of your career, of your clients, and of your users with every line of code.</p> <p>The overall speed of the development of the project gradually increases if everyone starts caring about the code.</p> <h3>References</h3> <p>Any fool can write code that a computer can understand. Good programmers write code that humans can understand. - <a href=\"http://www.softwarequotes.com/showquotes.aspx?id=573&amp;name=Fowler,Martin\">Martin Fowler</a>, Refactoring: Improving the Design of Existing Code by Martin Fowler, Kent Beck (Contributor), John Brant (Contributor), William Opdyke, don Roberts, ISBN: 0201485672</p> <p>Beauty of style and harmony and grace and good rhythm depends on simplicity. — Plato</p> <p><a href=\"http://www.informit.com/title/0321413091\">Implementation Patterns</a> by Kent Beck</p>",
      "category": 1,
      "bitly": "gsNtRt"
    },
    {
      "title": "Write small and focused interfaces",
      "url": "focused-interfaces",
      "summary": "Also known as the <b>'interface segregation principle'</b>. Many specific interfaces are better than one combined general interface.",
      "description": "<h3>Also known as</h3> <p>Interface Segregation Principle: Clients should not be forced to depend upon interfaces that they don't use.</p> <p>Alternate Definition: The dependency of one class to another one should depend on the smallest possible interface</p> <h3>Motivation</h3> <p>How do I design a interface?</p> <h3>Applicability</h3> <p>As we define our interfaces, it becomes important that we clearly understand the role the interface plays within the context of our application, when defining the operation on an interface, we should do so in a manner that doesn't accommodate multiple roles. Therefore, an interface should be responsible for allowing an object to assume a SINGLE ROLE, assuming the class of which that object is an instance implements that interface.</p> <h3>Application</h3> <p>Like every principle, Interface Segregation Principle requires additional time and effort spent to apply it during the design time and increase the complexity of code. But it produces a flexible design. If we are going to apply it more than necessary, it will result in a code containing a lot of interfaces with single methods, so applying should be done based on experience and common sense in identifying the areas where extension of code are more likely to happen in the future.</p> <h3>Consequences</h3> <p>This principle is important because it encourages two very important ingredients of a good software design:</p> • High cohesion - Keep all related methods together<br> • Low coupling - Keep dependence of one another to the bare minimum<br> <br> <p>Changes to fat interfaces tend to cause a ripple affect to classes who shouldn't have been affected in the first place.</p> <h3>Samples</h3> <p>Java Collection API is a good example on interface segregation. Classes can depend on Collection, List, Set, SortedSet etc. depending on what type of collection they want to use. If everything was bundled in a single interface then any change to that interface would mean a ripple effect in all collection classes. All types of Lists maintain a high cohesion. Client code is dependent on minimal interface required.</p> <h3>References</h3> • <a href=\"http://www.objectmentor.com/resources/articles/isp.pdf\">http://www.objectmentor.com/resources/articles/isp.pdf</a><br> • The <a href=\"http://www.sonarsource.org/clean-up-design-at-class-level-with-sonar/\">LCOM4 metric in Sonar</a> can help reveal violations of this principle in an existing code base.<br> <br>",
      "category": 3,
      "bitly": "gkrskx"
    },
    {
      "title": "You build it, you run it!",
      "url": "build-it-run-it",
      "summary": "<blockquote><p>The <b>development team</b> is responsible for the software in production.</p><p>The best way to completely automate operations is to have to developers be responsible for running the software they develop. [...] There is no separate operations department at Amazon:<br />you build it; you run it.</blockquote><em>Werner Vogels</em>",
      "description": "<h3>Motivation</h3> <p>Often development teams are totally unaware on how their software behaves in production and what the effect is on the end users. All problems are experienced by the operations department and any complaints are handled by first and second line support. The pain of low quality software is not felt by the developers.</p> <h3>Application</h3> <p>Create autonomous systems and build multidisciplinary teams around them that are responsible for the system in production.</p> <h3>References</h3> <p>The principle \"you build it, you run it\". was used by Werner Vogels to explain the organisation of the development teams at Amazon.</p>",
      "category": 2
    },
    {
      "title": "You get what you measure",
      "url": "what-you-measure",
      "summary": "Metrics are useful, but beware of <b>tunnel vision</b>. If you focus exclusively on any specific quality attributes (like code coverage), other attributes may suffer.<br /><br />This effect is magnified when the carrot or the stick is involved, such as a target code coverage ordained by management.",
      "description": "<p>Whenever you introduce some sort of <a href=\"http://essentials.xebia.com/make-it-visible\">visible metric</a>, like Code Coverage Analysis or a <a href=\"http://sonarqube.org/\">Sonar</a> violations count, you introduce a pressure to improve that metric. You can multiply the effect by setting a goal or KPI or cash bonus on achieving some sort of target value. Worse still, you can set a penalty on not reaching that target value. Goals and target values are pretty arbitrary anyway. Sure, 80% coverage is better than 78%, but why not aim for 82?</p> <p>The greater you make this pressure, the more you run the risk of (a) people gaming the system and (b) people over-optimizing to the detriment of aspects unmeasured. Your metric may end up doing more harm than good.</p> <p>All this notwithstanding, metrics and measurement are generally good things. They're a useful tool for <a href=\"http://essentials.xebia.com/improve-continuously\">improving</a> your software development practice, or indeed any other. To avoid these pitfalls:</p> • pick a range of complementary metrics, to avoid too narrow a focus<br> • be honest about whether any metrics improvement is of actual benefit or just window-dressing<br> • periodically reevaluate whether you're still measuring the right things<br> • aim for an improving trend in all metrics, rather than specific threshold values.<br> <br>",
      "category": 2
    },
    {
      "title": "Your solution should not be more complicated than the problem",
      "url": "kiss",
      "summary": "Also known as:<br /><br /> • The simplest thing that could possibly work<br /> • Keep It Simple, Stupid (KISS)<br /> • Less is more<br /> • You Ain't Gonna Need It (YAGNI)",
      "description": "<h3>Also known as</h3> • The simplest thing that could possibly work<br> • Keep It Simple, Stupid (KISS)<br> • Less is more<br> • You Ain't Gonna Need It (YAGNI)<br> <br> <h3>Motivation</h3> <p>When designing systems or finding solutions for problems in software development, we go for the simplest possible solution. We make things more complicated when we have concrete requirements for them no sooner. The core idea behind this is that it is a waste to spend time on things you may not need in the future.</p> <h3>Applicability</h3> <p>This applies to all the engineering that we do. This does not mean that there should have no design, on the contrary design is often a very important activity. We state that design has to be based on real and current requirements.</p> <h3>Application</h3> <p>On the topic of software development it means that we do not design our objects for possible future needs and architectures. Instead we design them for the current need that we have right now, and refactor once we come up against a new requirement or challenge.</p> <h3>Consequences</h3> <p>When we do this right we achieve three things:</p> • We avoid unnecessary work, since many of the things we might need in the future will prove to be useless<br> • We avoid unnecessary complexity, since we only have to deal with our current actual requirements, and the dead code of point 1 will not get in the way<br> • We follow the agile principle of deciding at the last responsible moment. By only implementing what is actually necessary we implement things at the time when we know most about them, not sooner, leading to better design<br> <br> <h3>Samples</h3> <p>Every project has examples of overcomplicating matters. It often starts with the technology and infrastructure choices we make. Does this client indeed require webframework X and database Y and workflowengine Z? It goes down to code we write.</p> <h3>References</h3> • <a href=\"http://en.wikipedia.org/wiki/KISS_principle\">http://en.wikipedia.org/wiki/KISS_principle</a><br> • <a href=\"http://people.apache.org/~fhanik/kiss.html\">http://people.apache.org/~fhanik/kiss.html</a><br> <br>",
      "category": 3,
      "bitly": "h79VId"
    },
    {
      "title": "Honor the timebox",
      "url": "honor-the-timebox",
      "summary": "You cannot stretch the boundaries of a timebox. The promise of having at least something at the end of a timebox should never be broken.",
      "description": "<p>You cannot stretch the boundaries of a timebox. The promise of having at least something at the end of a timebox should never be broken.</p>",
      "category": 2,
      "bitly": "eFftF0",
      "deprecated": true
    },
    {
      "title": "Do what you think is right, not always what you were told to do",
      "url": "do-the-right-thing",
      "summary": "Dare to push back.<br /><br />You are a professional, not a robot.",
      "description": "<p>Dare to push back!</p> <p>You are a professional, not a robot. If in your professional judgment, some course of action is wrong in the given situation, it is your professional responsibility to say so.</p>",
      "category": 1,
      "bitly": "h3fZ4X",
      "deprecated": true
    },
    {
      "title": "Beware of Heisenbugs",
      "url": "heisenbergs-principle",
      "summary": "<blockquote>The mesurement of position necessarily disturbs a particle's momentum, and vice versa.</blockquote><em>Werner Heisenberg</em><br /><br />Similarly, inspecting a running program might alter the behaviour of the program, known as a Heisenbug.",
      "description": "<blockquote><p>\"The more closely you look at one thing, the less closely can you see something else.\"</p></blockquote><h3>Motivation</h3><p>A heisenbug (named after the Heisenberg Uncertainty Principle) is a computer bug that disappears or alters its characteristics when an attempt is made to understand what's going on. Needless to say that bugs like these are really hard to debug. You need to be aware of the fact that behaviour <b>can</b> change as a consequence of your attempt to understand its root cause.</p><h3>Applicability</h3><p>There is no golden rule for the situation in which Heisenbugs can turn up - which makes them even harder to trap. Just to give you some examples of situations in which Heisenbugs might occur:</p> • You are stepping through a thread that may cause racing conditions when executing normally.<br /> • By attaching a debugger, you are influencing some properties of the Java VM's normal execution: setting watches might suggest more synchronization than what you would have in normal circumstances, the overhead of having the debugger attached might alter the amount of memory normally available to your application, etc.<br />  • If you test code by basically using a loopback type of construct (calling from your test into application code running in the same VM), there is a risk of sharing a lock that would never be shared if you call your application code remotely, from another VM.<br /><p>Heisenbugs are nasty, because your code might run successfully while testing or debugging, while it might fail when running in production. At Xebia, we care about having all your code tested. You <em>do</em> however need to make sure that you are testing the right thing. There is no excuse for not writing tests, but having tests running to completion successfully is no excuse for failing production code.</p><h3>Application</h3><p>So, what are you going to do about it? How do you prevent bugs like these from appearing in your code, and how do you spot their appearance. There's more than just a single word of advice on that:</p>  • Mimic the production environment as closely as possible while running your test. (Consider if there are any differences between the hardware running the tests and the hardware running your code in production.)<br /> • If you have a bug, never stop chasing it until you have a test that reproduces it.<br />  • Don't rely on coincidence for recreating the bug in your test. It might be that you can reproduce the bug by putting in a Thread.sleep() on your system, while on the system of your buddy it never shows up, since his system is executing faster or slower. If it's about concurrency related bugs, use <a href=\"http://code.google.com/p/multithreadedtc/\">MultithreadedTC</a> to forcefully recreate the different states in which your running code might end up being.<br />  • Understand Java's memory model.<br />  • Understand the differences between Java code running on different platforms.<br /> • Be aware of the limitation of line and branch coverage reports: they might show that your test code hit a particular branch or line, but it doesn't factor in differences in the state of the rest of your application. In other words, 100% branch and line coverage and a successful build does not mean you don't have Heisenbugs.<br /><h3>Consequences</h3><p>Following the advice above, has a couple of consequences.</p>  • Having tests run on your own system only might no longer be enough to proof correctness of your program. You could get another system to replicate the runtime production environment, or - and that's the better idea - you make sure you have an automated build on an environment that reflects production.<br />  • Using MultithreadedTC requires that your code actually lets itself be forced into different states. No example here. Just give it a try, and you will know what I mean.<br /> • Ideally, the only assumptions your tests make on the internals of your classes should be based on the contract defined by them, not by the implementation. However, there might be situations in which the need to force your objects to go into a certain state, you <b>do</b> need to factor in assumptions on the internals of these objects. That might not be ideal, but it's a cheap price for increasing the robustness of your software.<br /><h3>References</h3> • <a href=\"http://en.wikipedia.org/wiki/Unusual_software_bug#Heisenbug\">Wikipedia on Heisenbug</a><br /> • <em><a href=\"http://portal.acm.org/citation.cfm?id=101328.101333\">Heisenberg Uncertainty</a></em>, F. Laplante, ACM SIGSOFT Software Engineering Notes, October 1990<br />",
      "category": 4,
      "bitly": "euBFXg",
      "deprecated": true
    }
  ]
}
